
<!-- saved from url=(0043)http://pymacs.progiciels-bpi.ca/pymacs.html -->
<html xmlns:fp="http://pinard.progiciels-bpi.ca"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="generator" content="HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
  

  <title xmlns="http://www.w3.org/1999/xhtml">Pymacs version
  0.24-beta2</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="./Pymacs version 0.24-beta2_files/gabarit.css" type="text/css">
<style xmlns="http://www.w3.org/1999/xhtml" type="text/css">
/**/

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 6387 2010-08-13 12:23:41Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: left }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

/**/
</style>
</head>

<body>
  <div align="center">
    <table cellpadding="0" cellspacing="0">
      <tbody><tr>
        <td colspan="3">
          <div class="title">
            <h3>Pymacs framework</h3>
          </div>
        </td>
      </tr>

      <tr>
        <td class="body" valign="top" align="center">
          <table>
            <tbody><tr>
              <td>
                <div xmlns="http://www.w3.org/1999/xhtml" class="document" id="pymacs-version-0-24-beta2">
                  <h1 class="title">Pymacs version 0.24-beta2</h1>

                  <h2 class="subtitle" id="extending-emacs-with-python">Extending Emacs
                  with Python</h2>

                  <blockquote>
                    <table class="docutils field-list" frame="void" rules="none">
                      <colgroup><col class="field-name">
                      <col class="field-body">

                      </colgroup><tbody valign="top">
                        <tr class="field">
                          <th class="field-name">Author:</th>

                          <td class="field-body">François
                          Pinard</td>
                        </tr>

                        <tr class="field">
                          <th class="field-name">Email:</th>

                          <td class="field-body"><a class="reference external" href="mailto:pinard@iro.umontreal.ca">pinard@iro.umontreal.ca</a></td>
                        </tr>

                        <tr class="field">
                          <th class="field-name">Copyright:</th>

                          <td class="field-body">© Progiciels
                          Bourbeau-Pinard inc., Montréal 2003,
                          2008, 2010</td>
                        </tr>
                      </tbody>
                    </table>
                  </blockquote>

                  <div class="contents topic" id="contents">
                    <p class="topic-title first">Contents</p>

                    <ul class="auto-toc simple">
                      <li>
                        <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#introduction" id="id4" name="id4">1&nbsp;&nbsp;&nbsp;Introduction</a>

                        <ul class="auto-toc">
                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#what-is-pymacs" id="id5" name="id5">1.1&nbsp;&nbsp;&nbsp;What is Pymacs?</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#documentation-and-examples" id="id6" name="id6">1.2&nbsp;&nbsp;&nbsp;Documentation and
                          examples</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#other-resources" id="id7" name="id7">1.3&nbsp;&nbsp;&nbsp;Other resources</a></li>
                        </ul>
                      </li>

                      <li>
                        <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#installation" id="id8" name="id8">2&nbsp;&nbsp;&nbsp;Installation</a>

                        <ul class="auto-toc">
                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#check-the-search-paths" id="id9" name="id9">2.1&nbsp;&nbsp;&nbsp;Check the search
                          paths</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#edit-the-configuration-file" id="id10" name="id10">2.2&nbsp;&nbsp;&nbsp;Edit the configuration
                          file</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#check-if-pymacs-would-work" id="id11" name="id11">2.3&nbsp;&nbsp;&nbsp;Check if Pymacs would
                          work</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#install-the-pymacs-proper" id="id12" name="id12">2.4&nbsp;&nbsp;&nbsp;Install the Pymacs
                          proper</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#prepare-your-emacs-file" id="id13" name="id13">2.5&nbsp;&nbsp;&nbsp;Prepare your <tt class="file docutils literal">.emacs</tt>
                          file</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#porting-and-caveats" id="id14" name="id14">2.6&nbsp;&nbsp;&nbsp;Porting and caveats</a></li>
                        </ul>
                      </li>

                      <li>
                        <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#emacs-lisp-structures-and-python-objects" id="id15" name="id15">3&nbsp;&nbsp;&nbsp;Emacs Lisp
                        structures and Python objects</a>

                        <ul class="auto-toc">
                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#conversions" id="id16" name="id16">3.1&nbsp;&nbsp;&nbsp;Conversions</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#simple-objects" id="id17" name="id17">3.2&nbsp;&nbsp;&nbsp;Simple objects</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#sequences" id="id18" name="id18">3.3&nbsp;&nbsp;&nbsp;Sequences</a></li>

                          <li>
                            <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#opaque-objects" id="id19" name="id19">3.4&nbsp;&nbsp;&nbsp;Opaque objects</a>

                            <ul class="auto-toc">
                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#emacs-lisp-handles" id="id20" name="id20">3.4.1&nbsp;&nbsp;&nbsp;Emacs Lisp
                              handles</a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#python-handles" id="id21" name="id21">3.4.2&nbsp;&nbsp;&nbsp;Python
                              handles</a></li>
                            </ul>
                          </li>
                        </ul>
                      </li>

                      <li>
                        <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#usage-on-the-emacs-lisp-side" id="id22" name="id22">4&nbsp;&nbsp;&nbsp;Usage on the Emacs Lisp
                        side</a>

                        <ul class="auto-toc">
                          <li>
                            <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#special-emacs-lisp-functions" id="id23" name="id23">4.1&nbsp;&nbsp;&nbsp;Special Emacs
                            Lisp functions</a>

                            <ul class="auto-toc">
                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-exec" id="id24" name="id24">4.1.1&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-exec</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-eval" id="id25" name="id25">4.1.2&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-eval</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-call" id="id26" name="id26">4.1.3&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-call</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-apply" id="id27" name="id27">4.1.4&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-apply</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-load" id="id28" name="id28">4.1.5&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-load</strong></a></li>
                            </ul>
                          </li>

                          <li>
                            <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#special-emacs-lisp-variables" id="id29" name="id29">4.2&nbsp;&nbsp;&nbsp;Special Emacs
                            Lisp variables</a>

                            <ul class="auto-toc">
                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-python-command" id="id30" name="id30">4.2.1&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-python-command</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-load-path" id="id31" name="id31">4.2.2&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-load-path</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-trace-transit" id="id32" name="id32">4.2.3&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-trace-transit</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-forget-mutability" id="id33" name="id33">4.2.4&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-forget-mutability</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-mutable-strings" id="id34" name="id34">4.2.5&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-mutable-strings</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#timeout-variables" id="id35" name="id35">4.2.6&nbsp;&nbsp;&nbsp;Timeout
                              variables</a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-auto-restart" id="id36" name="id36">4.2.7&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-auto-restart</strong></a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#pymacs-dreadful-zombies" id="id37" name="id37">4.2.8&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-dreadful-zombies</strong></a></li>
                            </ul>
                          </li>
                        </ul>
                      </li>

                      <li>
                        <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#usage-on-the-python-side" id="id38" name="id38">5&nbsp;&nbsp;&nbsp;Usage on the Python side</a>

                        <ul class="auto-toc">
                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#python-setup" id="id39" name="id39">5.1&nbsp;&nbsp;&nbsp;Python setup</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#emacs-lisp-symbols" id="id40" name="id40">5.2&nbsp;&nbsp;&nbsp;Emacs Lisp symbols</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#dynamic-bindings" id="id41" name="id41">5.3&nbsp;&nbsp;&nbsp;Dynamic bindings</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#raw-emacs-lisp-expressions" id="id42" name="id42">5.4&nbsp;&nbsp;&nbsp;Raw Emacs Lisp
                          expressions</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#user-interaction" id="id43" name="id43">5.5&nbsp;&nbsp;&nbsp;User interaction</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#key-bindings" id="id44" name="id44">5.6&nbsp;&nbsp;&nbsp;Key bindings</a></li>
                        </ul>
                      </li>

                      <li>
                        <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#debugging" id="id45" name="id45">6&nbsp;&nbsp;&nbsp;Debugging</a>

                        <ul class="auto-toc">
                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#the-communication-protocol" id="id46" name="id46">6.1&nbsp;&nbsp;&nbsp;The communication
                          protocol</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#the-pymacs-buffer" id="id47" name="id47">6.2&nbsp;&nbsp;&nbsp;The <strong class="code">*Pymacs*</strong> buffer</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#debugging-the-pymacs-helper" id="id48" name="id48">6.3&nbsp;&nbsp;&nbsp;Debugging the Pymacs
                          helper</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#emacs-usual-debugging" id="id49" name="id49">6.4&nbsp;&nbsp;&nbsp;Emacs usual
                          debugging</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#python-usual-debugging" id="id50" name="id50">6.5&nbsp;&nbsp;&nbsp;Python usual
                          debugging</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#auto-reloading-on-save" id="id51" name="id51">6.6&nbsp;&nbsp;&nbsp;Auto-reloading on
                          save</a></li>
                        </ul>
                      </li>

                      <li>
                        <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#administrative-miscellany" id="id52" name="id52">7&nbsp;&nbsp;&nbsp;Administrative
                        miscellany</a>

                        <ul class="auto-toc">
                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#development-history" id="id53" name="id53">7.1&nbsp;&nbsp;&nbsp;Development history</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#should-it-come-with-emacs" id="id54" name="id54">7.2&nbsp;&nbsp;&nbsp;Should it come with
                          Emacs?</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#the-future-of-pymacs" id="id55" name="id55">7.3&nbsp;&nbsp;&nbsp;The future of
                          Pymacs</a></li>
                        </ul>
                      </li>

                      <li>
                        <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#technical-miscellany" id="id56" name="id56">8&nbsp;&nbsp;&nbsp;Technical miscellany</a>

                        <ul class="auto-toc">
                          <li>
                            <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#known-bugs-or-limitations" id="id57" name="id57">8.1&nbsp;&nbsp;&nbsp;Known bugs or
                            limitations</a>

                            <ul class="auto-toc">
                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#needed-control-on-stack-unwinding" id="id58" name="id58">8.1.1&nbsp;&nbsp;&nbsp;Needed
                              control on stack unwinding</a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#possible-memory-leak" id="id59" name="id59">8.1.2&nbsp;&nbsp;&nbsp;Possible
                              memory leak</a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#death-from-a-ctrl-c" id="id60" name="id60">8.1.3&nbsp;&nbsp;&nbsp;Death from a
                              Ctrl-C</a></li>
                            </ul>
                          </li>

                          <li>
                            <a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#suggestions-to-ponder" id="id61" name="id61">8.2&nbsp;&nbsp;&nbsp;Suggestions to
                            ponder</a>

                            <ul class="auto-toc">
                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#python-driven-pymacs" id="id62" name="id62">8.2.1&nbsp;&nbsp;&nbsp;Python-driven
                              Pymacs</a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#autoloading-interface" id="id63" name="id63">8.2.2&nbsp;&nbsp;&nbsp;Autoloading
                              interface</a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#handling-more-special-forms" id="id64" name="id64">8.2.3&nbsp;&nbsp;&nbsp;Handling more special
                              forms</a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#support-for-python-dictionaries" id="id65" name="id65">8.2.4&nbsp;&nbsp;&nbsp;Support
                              for Python dictionaries</a></li>

                              <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#a-nicer-pymacs-buffer" id="id66" name="id66">8.2.5&nbsp;&nbsp;&nbsp;A nicer
                              <strong class="code">*Pymacs*</strong>
                              buffer</a></li>
                            </ul>
                          </li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#speed-issues" id="id67" name="id67">8.3&nbsp;&nbsp;&nbsp;Speed issues</a></li>

                          <li><a class="reference internal" href="http://pymacs.progiciels-bpi.ca/pymacs.html#vim-related-thoughts" id="id68" name="id68">8.4&nbsp;&nbsp;&nbsp;Vim-related
                          thoughts</a></li>
                        </ul>
                      </li>
                    </ul>
                  </div><!--  -->

                  <p>There exists a <a class="reference external" href="http://webhostinggeeks.com/science/pymacs-framework-ro">
                  Romanian translation</a> of this manual.</p>
                  <!-- By `Alexander Ovsov` alovsov@gmail.com -->

                  <div class="section" id="introduction">
                    <h1><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id4">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>

                    <div class="section" id="what-is-pymacs">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id5">1.1&nbsp;&nbsp;&nbsp;What is Pymacs?</a></h2>

                      <p>Pymacs is a powerful tool which, once
                      started from Emacs, allows two-way
                      communication between Emacs Lisp and Python.
                      Pymacs aims to employ Python as an extension
                      language for Emacs rather than the other way
                      around, and this asymmetry is reflected in
                      some design choices. Within Emacs Lisp code,
                      one may load and use Python modules. Python
                      functions may themselves use Emacs services,
                      and handle Emacs Lisp objects kept in Emacs
                      Lisp space.</p>

                      <p>The goals are to write <em>naturally</em>
                      in both languages, debug with ease, fall back
                      gracefully on errors, and allow full
                      cross-recursion.</p>

                      <p>It is very easy to install Pymacs, as
                      neither Emacs nor Python need to be compiled
                      nor relinked. Emacs merely starts Python as a
                      subprocess, and Pymacs implements a
                      communication protocol between both
                      processes.</p>

                      <p>Report problems, documentation flaws, or
                      suggestions to François Pinard:</p>

                      <blockquote>
                        <ul class="simple">
                          <li><a class="reference external" href="mailto:pinard@iro.umontreal.ca">mailto:pinard@iro.umontreal.ca</a></li>
                        </ul>
                      </blockquote>
                    </div>

                    <div class="section" id="documentation-and-examples">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id6">1.2&nbsp;&nbsp;&nbsp;Documentation and
                      examples</a></h2>

                      <p>The main Pymacs site conveys the Pymacs
                      documentation (you are reading its Pymacs
                      manual right now) and distributions:</p>

                      <blockquote>
                        <ul class="simple">
                          <li><a class="reference external" href="http://pymacs.progiciels-bpi.ca/">http://pymacs.progiciels-bpi.ca</a></li>
                        </ul>
                      </blockquote>

                      <p>I expect average Pymacs users to have a
                      deeper knowledge of Python than Emacs Lisp.
                      People have widely varying approaches in
                      writing <tt class="file docutils literal">.emacs</tt> files, as
                      far as Pymacs is concerned:</p>

                      <blockquote>
                        <ul class="simple">
                          <li>Some can go and write almost no Emacs
                          Lisp, yet a bit is still necessary for
                          establishing a few loading hooks. For
                          many simple needs, one can do a lot
                          without having to learn much.</li>

                          <li>On the other hand, for more
                          sophisticated usages, people cannot
                          really escape knowing the Emacs Lisp API
                          to some extent, because they should be
                          familiar, programming-wise, with what is
                          a buffer, a point, a mark, etc. and what
                          are the allowed operations on those.</li>
                        </ul>
                      </blockquote>

                      <p>While Pymacs examples are no substitute
                      for a careful reading of the Pymacs manual,
                      the contemplation and study of others' nice
                      works may well enligthen and deepen your
                      understanding. A few examples are included
                      within the Pymacs distribution, each as a
                      subdirectory of the <tt class="file docutils literal">contrib/</tt>
                      directory, and each having its own <tt class="file docutils literal">README</tt> file.
                      These are listed below, easiest examples
                      first:</p>

                      <blockquote>
                        <ul class="simple">
                          <li>Paul Winkler's example

                            <ul>
                              <li><a class="reference external" href="http://pymacs.progiciels-bpi.ca/Winkler.html">
                              http://pymacs.progiciels-bpi.ca/Winkler.html</a></li>
                            </ul>
                          </li>

                          <li>Fernando Pérez' examples

                            <ul>
                              <li><a class="reference external" href="http://pymacs.progiciels-bpi.ca/Perez.html">
                              http://pymacs.progiciels-bpi.ca/Perez.html</a></li>

                              <li><a class="reference external" href="http://pymacs.progiciels-bpi.ca/contrib/Perez/">
                              http://pymacs.progiciels-bpi.ca/contrib/Perez/</a></li>
                            </ul>
                          </li>

                          <li>Giovanni Giorgi's files

                            <ul>
                              <li><a class="reference external" href="http://pymacs.progiciels-bpi.ca/Giorgi.html">
                              http://pymacs.progiciels-bpi.ca/Giorgi.html</a></li>

                              <li><a class="reference external" href="http://pymacs.progiciels-bpi.ca/contrib/Giorgi/">
                              http://pymacs.progiciels-bpi.ca/contrib/Giorgi/</a></li>
                            </ul>
                          </li>

                          <li>A reformatter for boxed comments

                            <ul>
                              <li><a class="reference external" href="http://pymacs.progiciels-bpi.ca/rebox.html">
                              http://pymacs.progiciels-bpi.ca/rebox.html</a></li>

                              <li><a class="reference external" href="http://pymacs.progiciels-bpi.ca/contrib/rebox/">
                              http://pymacs.progiciels-bpi.ca/contrib/rebox/</a></li>
                            </ul>
                          </li>
                        </ul>
                      </blockquote>

                      <p>A few more substantial examples of Pymacs
                      usage have been brought to my attention, and
                      are available externally (listed here in no
                      particular order):</p>

                      <blockquote>
                        <ul class="simple">
                          <li>pymdev — A Python Emacs Development
                          Module:

                            <ul>
                              <li><a class="reference external" href="http://www.toolness.com/pymdev/">http://www.toolness.com/pymdev/</a></li>
                            </ul>
                          </li>

                          <li>Ropemacs — Features like refactoring
                          and code-assists:

                            <ul>
                              <li><a class="reference external" href="http://rope.sf.net/ropemacs.html">http://rope.sf.net/ropemacs.html</a></li>

                              <li><a class="reference external" href="http://rope.sf.net/hg/ropemacs">http://rope.sf.net/hg/ropemacs</a></li>
                            </ul>
                          </li>

                          <li>Bicycle Repair Man — A Refactoring
                          Tool for Python:

                            <ul>
                              <li><a class="reference external" href="http://bicyclerepair.sourceforge.net/">
                              http://bicyclerepair.sourceforge.net/</a></li>
                            </ul>
                          </li>

                          <li>Emacs Freex — A personal wiki on
                          steroids:

                            <ul>
                              <li><a class="reference external" href="http://www.princeton.edu/~gdetre/software/freex/docs/index.html">
                              http://www.princeton.edu/%7Egdetre/software/freex/docs/index.html</a></li>
                            </ul>
                          </li>

                          <li>PyJde — Java dev source code browsing
                          features in Emacs using Python:

                            <ul>
                              <li><a class="reference external" href="http://code.google.com/p/pyjde/">http://code.google.com/p/pyjde/</a></li>
                            </ul>
                          </li>
                        </ul>
                      </blockquote>

                      <p>The QaTeX project was influenced by
                      Pymacs, according to its author:</p>

                      <blockquote>
                        <ul class="simple">
                          <li><a class="reference external" href="http://qatex.sourceforge.net/">http://qatex.sourceforge.net/</a></li>

                          <li><a class="reference external" href="http://www.pytex.org/doc/eurotex2005.pdf">
                          http://www.pytex.org/doc/eurotex2005.pdf</a></li>
                        </ul>
                      </blockquote>
                    </div>

                    <div class="section" id="other-resources">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id7">1.3&nbsp;&nbsp;&nbsp;Other resources</a></h2>

                      <p>You are welcome writing to or joining the
                      following mailing list, where there are a few
                      people around likely to give you
                      feedback:</p>

                      <blockquote>
                        <ul class="simple">
                          <li><a class="reference external" href="mailto:pymacs-devel@googlegroups.com">mailto:pymacs-devel@googlegroups.com</a></li>

                          <li><a class="reference external" href="https://groups.google.com/group/pymacs-devel/">
                          https://groups.google.com/group/pymacs-devel/</a></li>
                        </ul>
                      </blockquote>

                      <p>If you have no fear of wider crowds :-),
                      there still is:</p>

                      <blockquote>
                        <ul class="simple">
                          <li><a class="reference external" href="mailto:python-list@python.org">mailto:python-list@python.org</a></li>
                        </ul>
                      </blockquote>

                      <p>There are other Web sites specifically
                      about Pymacs. <a class="reference external" href="http://blog.objectsroot.com/">Giovanni
                      Giorgi</a> has one of them:</p>

                      <blockquote>
                        <ul class="simple">
                          <li><a class="reference external" href="http://blog.objectsroot.com/projects/pymacs/">
                          http://blog.objectsroot.com/projects/pymacs/</a></li>
                        </ul>
                      </blockquote>

                      <p>There is an entry for Pymacs on
                      Freshmeat:</p>

                      <blockquote>
                        <ul class="simple">
                          <li><a class="reference external" href="http://freshmeat.net/projects/pymacs/">http://freshmeat.net/projects/pymacs/</a></li>
                        </ul>
                      </blockquote>
                    </div>
                  </div>

                  <div class="section" id="installation">
                    <h1><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id8">2&nbsp;&nbsp;&nbsp;Installation</a></h1>

                    <div class="section" id="check-the-search-paths">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id9">2.1&nbsp;&nbsp;&nbsp;Check the search paths</a></h2>

                      <p>You should make sure that both Emacs and
                      Python are usable, whatever the directory
                      happens to be the current one. This is
                      particularly important at the time Emacs
                      launches Python under the scene, as Python
                      ought to be found then started. On most
                      systems, this means setting the search path
                      correctly.</p>

                      <p>The following notes, for MS Windows, have
                      been provided by Greg Detre.</p>

                      <ul>
                        <li>
                          <p class="first">After <tt class="docutils literal">Start / Run /
                          Cmd</tt>, type <tt class="docutils literal">python</tt>. If this
                          works wherever you are, then your Python
                          installation directory is already in your
                          system's <strong class="code">PATH</strong> environment
                          variable. If that's not the case, follow
                          the instructions here to add it:</p>

                          <blockquote>
                            <p><a class="reference external" href="http://www.computerhope.com/issues/ch000549.htm">
                            http://www.computerhope.com/issues/ch000549.htm</a></p>
                          </blockquote>
                        </li>

                        <li>
                          <p class="first">You may have to add the
                          directory containing the Python scripts
                          that you want to run through Pymacs to
                          your <strong class="code">PYTHONPATH</strong> variable, in
                          the same fashion as above. You can test
                          this by running Python, and then:</p>
                          <pre class="literal-block">import sys
sys.path
</pre>

                          <p>or just:</p>
                          <pre class="literal-block">import my_python_scripts
</pre>

                          <p>from somewhere besides your scripts
                          directory.</p>
                        </li>
                      </ul>
                    </div>

                    <div class="section" id="edit-the-configuration-file">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id10">2.2&nbsp;&nbsp;&nbsp;Edit the configuration
                      file</a></h2>

                      <p>In most cases, you may safely skip this
                      step, as it is only needed in unusual,
                      problematic circumstances. Merely check that
                      none of the following applies to you.</p>

                      <blockquote>
                        <ul class="simple">
                          <li>Under Aquamacs (which is a MacOS X
                          native port of Emacs), it has been
                          reported that one gets <cite>Lisp nesting
                          exceeds max-lisp-eval-depth</cite>
                          messages while interactively requesting
                          the documentation for Lisp functions (we
                          do not know why). If you have this
                          problem, edit file <tt class="file docutils literal">ppppconfig.py</tt>,
                          locate the line defining <strong class="code">DEFADVICE_OK</strong>, make sure
                          it gets the string <tt class="docutils literal">'nil'</tt> as a value,
                          instead of the string <tt class="docutils literal">'t'</tt>, then save
                          the edited file before proceeding
                          further. This should work around the
                          problem. The price to pay is that you
                          will not get the Python docstring for
                          modules imported through Pymacs.</li>
                        </ul>
                      </blockquote>
                    </div>

                    <div class="section" id="check-if-pymacs-would-work">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id11">2.3&nbsp;&nbsp;&nbsp;Check if Pymacs would
                      work</a></h2>

                      <p>To know, before installing Pymacs, if it
                      would work on your system, try the validation
                      suite by running <tt class="docutils literal">make check</tt>. The suite
                      is fairly elementary, but nevertheless, it is
                      able to detect some common show stoppers. To
                      check a particular Emacs and Python
                      combination, use <tt class="docutils literal">make check
                      EMACS=some_Emacs PYTHON=some_Python</tt>.</p>

                      <p>If <tt class="docutils literal">PYTHON</tt> is left unset
                      or empty, then the command for starting the
                      Pymacs helper is <tt class="docutils literal">python</tt>. Otherwise, it
                      may be set to give the full path of the
                      Python executable if it exists at some
                      location outside the program search path. It
                      may also be given when the interpreter name
                      is different, for exemple when the Python
                      version is part of the program name.</p>

                      <p>If <tt class="docutils literal">EMACS</tt>
                      is left unset or empty, then the command for
                      starting the Emacs editor is <tt class="docutils literal">emacs</tt>. For normal
                      Pymacs usage, Emacs is launched by the user
                      long before Pymacs is itself started, and
                      consequently, there is absolutely no need to
                      tell Pymacs which Emacs is needed. For the
                      validation suite however, it may be set to
                      give the full path of the executable if the
                      Emacs program exists at some location outside
                      the program search path. It may also be given
                      when the editor name is different, for
                      example when the Emacs version is part of the
                      program name, or when this is a different
                      editor. For example, <tt class="docutils literal">make check
                      EMACS=xemacs</tt> runs the validation suite
                      using <tt class="docutils literal">xemacs</tt> for an
                      editor.</p>

                      <p>The remaining of this section may be
                      safely be skipped for mere Pymacs
                      installation.</p>

                      <p>I did not base the validation suite on
                      Junit (the Python unit testing framework is a
                      re-implementation of it), but on Codespeak's
                      pylib <tt class="file docutils literal">py.test</tt>, which
                      is much simpler, and still very powerful. The
                      <strong class="code">pylib</strong> project
                      is driven by Holge Kregel, but attracted some
                      Python brains, like Armin Rigo (known for
                      Psyco, among other things -- I think his
                      <strong class="code">lsprof</strong> has also
                      been added to Python 2.5 under the name
                      <strong class="code">cProfile</strong>). This
                      gang addresses overdone/heavy methods in
                      Python, and do them better. Even <tt class="file docutils literal">py.test</tt> is a bit
                      more complex that I would want, and has (or
                      at least had) flaws on the Unicode side, so I
                      rewrote my own, as a simple single file. I
                      merely translated it from French to English,
                      to make it more distributable within
                      Pymacs.</p>

                      <p>I initially tried using Emacs stdin and
                      stdout for communicating expressions to
                      evaluate and getting back results, from
                      within the validation suite. This did not
                      prove useful so, so after some fight, I
                      reluctantly put this avenue aside. Currently,
                      the suite writes problems in files, for Emacs
                      to read, and Emacs writes replies in files,
                      for the suite to check. Busy waiting (with
                      small sleep added in the loops) is used on
                      both sides. This is all too heavy, and it
                      slows down the suite. Hopefully, the suite is
                      not run often, this is not a real
                      problem.</p>
                    </div>

                    <div class="section" id="install-the-pymacs-proper">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id12">2.4&nbsp;&nbsp;&nbsp;Install the Pymacs
                      proper</a></h2>

                      <p>Pymacs is a small package. Putting the
                      documentation and administrative files aside,
                      there is one Python file and one Emacs Lisp
                      file to it, to be installed in turn. Always
                      start with the Python file.</p>

                      <ul>
                        <li>
                          <p class="first">For the Python part</p>

                          <p>From the top-level of the Pymacs
                          distribution, execute <tt class="docutils literal">make install</tt>. If
                          you do not have a Make program (Microsoft
                          Windows?) read the <tt class="docutils literal">Makefile</tt> file and
                          emulate what <tt class="docutils literal">make install</tt>
                          does, maybe something like this:</p>
                          <pre class="literal-block">python pppp -C ppppconfig.py pppp.rst.in pymacs.el.in \
  pymacs.rst.in Pymacs contrib tests
python setup.py install
</pre>

                          <p>Without <tt class="docutils literal">make install</tt>, you
                          might also have to combine the two first
                          lines above into a single longer one,
                          without the backslash.</p>

                          <p>If the Python interpreter has a
                          non-standard name or location, rather do
                          <tt class="docutils literal">make install
                          PYTHON=Some_Python</tt> (see the previous
                          section for a discussion). First, the
                          script copies a few source files while
                          configuring them: it presets the version
                          string and the name of the Python
                          interpreter, it also adapts the Python
                          source code which might differ, for
                          example, between Python 2 and Python 3.
                          Second, it installs the Python package
                          through the Python standard Distutils
                          tool. To get an option reminder, do
                          <tt class="docutils literal">python
                          setup.py install <span class="pre">--help</span></tt>. Consult the
                          Distutils documentation if you need more
                          information about this.</p>

                          <p>That's normally all to it. To check
                          that <tt class="file docutils literal">pymacs.py</tt> is
                          properly installed, start an interactive
                          Python session and type <tt class="docutils literal">from Pymacs import
                          lisp</tt>: you should not receive any
                          error.</p>

                          <p>A special difficulty arises when the
                          particular Python you use does not have
                          Distutils already installed. In such a
                          case, <tt class="docutils literal">make
                          install</tt> prints a warning, leaving to
                          you the task of figuring out where the
                          <tt class="docutils literal">Pymacs/</tt>
                          directory is best copied, and making that
                          copy.</p>
                        </li>

                        <li>
                          <p class="first">For the Emacs part</p>

                          <p>This is usually done by hand now.
                          First select some directory along the
                          list kept in your Emacs <strong class="code">load-path</strong>, for which you
                          have write access, and copy file
                          <tt class="file docutils literal">pymacs.el</tt> in
                          that directory.</p>

                          <p>If you want speed, you should ideally
                          byte-compile this file. To do so, go to
                          that directory, launch Emacs, then give
                          the command <tt class="docutils literal"><span class="pre">M-x</span> <span class="pre">byte-compile-file</span> RET
                          pymacs.el RET</tt>. If for some reason
                          you intend to such commands often, you
                          could create a little script to do so.
                          Here is an example of such a script,
                          assuming here that you use Emacs and want
                          to install in directory <tt class="file docutils literal">~/share/emacs/lisp/</tt>:</p>
                          <pre class="literal-block">#!/bin/bash
cp pymacs.el ~/share/emacs/lisp/
emacs -batch -eval '(byte-compile-file "~/share/emacs/lisp/pymacs.el")'
</pre>

                          <p>You should be done now. To check that
                          <tt class="file docutils literal">pymacs.el</tt> is
                          properly installed, return to your usual
                          directories, start Emacs and give it the
                          command <tt class="docutils literal"><span class="pre">M-x</span> <span class="pre">load-library</span> RET pymacs
                          RET</tt>: you should not receive any
                          error.</p>
                        </li>
                      </ul>

                      <p>Some features from previous Pymacs
                      releases have been dropped:</p>

                      <ul class="simple">
                        <li>Environment variable <tt class="docutils literal">PYMACS_EMACS</tt> is
                        gone, and environment variable <tt class="docutils literal">PYMACS_PYTHON</tt> is
                        usually not needed.</li>

                        <li>There used to be a script for
                        installing the Emacs Lisp file. As it was
                        difficult to get it right in all
                        circumstances; the script grew an
                        interactive mode and lot of options. This
                        is just not worth the complexity, so this
                        script is now gone.</li>

                        <li>Examples were all installed
                        automatically, but at least for some of
                        them, this was more pollution than help.
                        You may browse the contents of the
                        <tt class="file docutils literal">contrib/</tt>
                        directory to learn about available
                        examples.</li>
                      </ul>
                    </div>

                    <div class="section" id="prepare-your-emacs-file">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id13">2.5&nbsp;&nbsp;&nbsp;Prepare your <tt class="file docutils literal">.emacs</tt>
                      file</a></h2>

                      <p>The <tt class="file docutils literal">.emacs</tt> file is
                      not given in the distribution, you likely
                      have one already in your home directory. You
                      need to add these lines:</p>
                      <pre class="literal-block">(autoload 'pymacs-apply "pymacs")
(autoload 'pymacs-call "pymacs")
(autoload 'pymacs-eval "pymacs" nil t)
(autoload 'pymacs-exec "pymacs" nil t)
(autoload 'pymacs-load "pymacs" nil t)
;;(eval-after-load "pymacs"
;;  '(add-to-list 'pymacs-load-path YOUR-PYMACS-DIRECTORY"))
</pre>

                      <p>If you plan to use a special directory to
                      hold your own Pymacs code in Python, which
                      should be searched prior to the usual Python
                      import search path, then uncomment the last
                      two lines (by removing the semi-colons) and
                      replace <em class="var">YOUR-PYMACS-DIRECTORY</em> by the name
                      of your special directory. If the file
                      <tt class="file docutils literal"><span class="pre">~/.emacs</span></tt>
                      does not exist, merely create it with the
                      above lines. You are now all set to use
                      Pymacs.</p>

                      <p>To check this, start a fresh Emacs
                      session, and type <tt class="docutils literal"><span class="pre">M-x</span> <span class="pre">pymacs-eval</span> RET</tt>. Emacs
                      should prompt you for a Python expression.
                      Try <tt class="docutils literal"><span class="pre">repr(2L**111)</span> RET</tt> (rather
                      use <tt class="docutils literal"><span class="pre">repr(2**111)</span> RET</tt> if you are
                      using Python 3). The mini buffer should
                      display
                      <cite>"2596148429267413814265248164610048L"</cite>
                      (yet there is no <tt class="docutils literal">L</tt> suffix in Python
                      3).</p>

                      <p>Let's do a second test. Whether in the
                      same Emacs session or not, <tt class="docutils literal"><span class="pre">M-x</span> <span class="pre">pymacs-load</span> RET</tt> should
                      prompt you for a Python module name. Reply
                      <tt class="docutils literal">os RET RET</tt>
                      (the second <tt class="docutils literal">RET</tt> is for accepting
                      the default prefix). This should have the
                      effect of importing the Python <strong class="code">os</strong> module within Emacs.
                      Typing <tt class="docutils literal"><span class="pre">M-:</span> <span class="pre">(os-getcwd)</span> RET</tt> should echo
                      the current directory in the message buffer,
                      as returned by the <strong class="code">os.getcwd</strong> Python
                      function.</p>
                    </div>

                    <div class="section" id="porting-and-caveats">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id14">2.6&nbsp;&nbsp;&nbsp;Porting and caveats</a></h2>

                      <p>Pymacs has been initially developed on
                      Linux, Python 1.5.2, and Emacs 20, and is
                      currently developed using Python 2.6, Python
                      3.1, Emacs 23.1 and XEmacs 21.4. It is
                      expected to work out of the box on many
                      flavours of Unix, MS Windows and Mac OSX, and
                      also on many version of Python, Emacs and
                      XEmacs.</p>

                      <p>From Pymacs 0.23 and upwards, Python 2.2
                      or better is likely needed, and for the
                      Pymacs proper, I rely on testers or users for
                      portability issues. However, the validation
                      suite itself requires Python 2.6 or better,
                      someone might choose to contribute the back
                      porting. Python 3.1 support has been added
                      for Pymacs 0.24.</p>

                      <p>Pymacs uses Emacs weak hash tables. It can
                      run without them, but then, complex Python
                      objects transmitted to Emacs will tie Python
                      memory forever. It should not be a practical
                      problem in most simple cases. Some later
                      versions of Emacs 20 silently create ordinary
                      tables when asked for weak hash tables. Older
                      Emacses do not have hash tables.</p>

                      <p>The <tt class="file docutils literal">Pymacs</tt> Python
                      package holds a single <tt class="file docutils literal">pymacs.py</tt> file
                      (and the mandatory <tt class="file docutils literal">__init__.py</tt>).
                      Programmers might elect, but are not
                      required, to install their own Pymacs
                      applications either as sub-modules or
                      sub-packages on <tt class="file docutils literal">Pymacs</tt>.</p>
                    </div>
                  </div>

                  <div class="section" id="emacs-lisp-structures-and-python-objects">
                    <h1><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id15">3&nbsp;&nbsp;&nbsp;Emacs Lisp structures and Python
                    objects</a></h1>

                    <div class="section" id="conversions">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id16">3.1&nbsp;&nbsp;&nbsp;Conversions</a></h2>

                      <p>Whenever Emacs Lisp calls Python functions
                      giving them arguments, these arguments are
                      Emacs Lisp structures that should be
                      converted into Python objects in some way.
                      Conversely, whenever Python calls Emacs Lisp
                      functions, the arguments are Python objects
                      that should be received as Emacs Lisp
                      structures. We need some conventions for
                      doing such conversions.</p>

                      <p>Conversions generally transmit mutable
                      Emacs Lisp structures as mutable objects on
                      the Python side, in such a way that
                      transforming the object in Python will
                      effectively transform the structure on the
                      Emacs Lisp side (strings are handled a bit
                      specially however, see below). The other way
                      around, Python objects transmitted to Emacs
                      Lisp often loose their mutability, so
                      transforming the Emacs Lisp structure is not
                      reflected on the Python side.</p>

                      <p>Pymacs sticks to standard Emacs Lisp, it
                      explicitly avoids various Emacs Lisp
                      extensions. One goal for many Pymacs users is
                      taking some distance from Emacs Lisp, so
                      Pymacs is not overly pushing users deeper
                      into it.</p>
                    </div>

                    <div class="section" id="simple-objects">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id17">3.2&nbsp;&nbsp;&nbsp;Simple objects</a></h2>

                      <p>Emacs Lisp <strong class="code">nil</strong> and the equivalent Emacs
                      Lisp <tt class="docutils literal">()</tt>
                      yield Python <strong class="code">None</strong>. Python <strong class="code">None</strong>, Python <strong class="code">False</strong> and the Python empty
                      list <tt class="docutils literal">[]</tt> are
                      returned as <strong class="code">nil</strong>
                      in Emacs Lisp. Notice the assymetry, in that
                      three different Python objects are mapped
                      into a single Emacs Lisp object. So, neither
                      <strong class="code">False</strong> nor
                      <tt class="docutils literal">[]</tt> are
                      likely produced by automatic conversions from
                      Emacs Lisp to Python.</p>

                      <p>Emacs Lisp <strong class="code">t</strong>
                      yields Python <strong class="code">True</strong>. Python <strong class="code">True</strong> is returned as
                      <strong class="code">t</strong> in Emacs
                      Lisp.</p>

                      <p>Emacs Lisp numbers, either integer or
                      floating, are converted in equivalent Python
                      numbers. Emacs Lisp characters are really
                      numbers and yield Python numbers. In the
                      other direction, Python numbers are converted
                      into Emacs Lisp numbers, with the exception
                      of long Python integers and complex
                      numbers.</p>

                      <p>Emacs Lisp strings are usually converted
                      into equivalent Python strings. As Python
                      strings do not have text properties, these
                      are not reflected. This may be changed by
                      setting the <strong class="code">pymacs-mutable-strings</strong>
                      option: if this variable is not
                      <strong class="code">nil</strong>, Emacs Lisp
                      strings are then transmitted opaquely. Python
                      strings are always converted into Emacs Lisp
                      strings. Python releases before version 3
                      make a distinction between Unicode and narrow
                      strings: Unicode strings are then produced on
                      the Python side for Emacs Lisp multi-byte
                      strings, but only when they do not fit in
                      ASCII, otherwise Python narrow strings are
                      produced. Conversely, Emacs Lisp multi-byte
                      strings are produced for Python strings, but
                      only when they do not fit ASCII, otherwise
                      Emacs Lisp uni-byte strings are produced.
                      Currently, Pymacs behaviour is undefined for
                      users wandering outside the limits of Emacs'
                      <strong class="code">utf-8</strong> coding
                      system.</p>

                      <p>Emacs Lisp symbols yield <tt class="docutils literal">lisp[STRING]</tt>
                      notations on the Python side, where
                      <em class="var">STRING</em> names the symbol.
                      In the other direction, Python <tt class="docutils literal">lisp[STRING]</tt>
                      corresponds to an Emacs Lisp symbol printed
                      with that <em class="var">STRING</em> which,
                      of course, should then be a valid Emacs Lisp
                      symbol name. As a convenience, <tt class="docutils literal">lisp.SYMBOL</tt> on the
                      Python side yields an Emacs Lisp symbol with
                      underscores replaced with hyphens; this
                      convention is welcome, as Emacs Lisp
                      programmers commonly prefer using dashes,
                      where Python programmers use underlines. Of
                      course, this <tt class="docutils literal">lisp.SYMBOL</tt> notation
                      is only usable when the <em class="var">SYMBOL</em> is a valid Python
                      identifier, while not being a Python
                      keyword.</p>
                    </div>

                    <div class="section" id="sequences">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id18">3.3&nbsp;&nbsp;&nbsp;Sequences</a></h2>

                      <p>The case of strings has been discussed in
                      the previous section.</p>

                      <p>Proper Emacs Lisp lists, those for which
                      the <strong class="code">cdr</strong> of last
                      cell is <strong class="code">nil</strong>,
                      are normally transmitted opaquely to Python.
                      If <strong class="code">pymacs-forget-mutability</strong> is
                      set, or if Python later asks for these to be
                      expanded, proper Emacs Lisp lists get
                      converted into Python lists, if we except the
                      empty list, which is always converted as
                      Python <strong class="code">None</strong>. In
                      the other direction, Python lists are always
                      converted into proper Emacs Lisp lists.</p>

                      <p>Emacs Lisp vectors are normally
                      transmitted opaquely to Python. However, if
                      <strong class="code">pymacs-forget-mutability</strong> is
                      set, or if Python later asks for these to be
                      expanded, Emacs Lisp vectors get converted
                      into Python tuples. In the other direction,
                      Python tuples are always converted into Emacs
                      Lisp vectors.</p>

                      <p>Remember the rule: <cite>Round parentheses
                      correspond to square brackets!</cite>. It
                      works for lists, vectors, tuples, seen from
                      either Emacs Lisp or Python.</p>

                      <p>The above choices were debatable. Since
                      Emacs Lisp proper lists and Python lists are
                      the bread-and-butter of algorithms modifying
                      structures, at least in my experience, I
                      guess they are more naturally mapped into one
                      another, this spares many casts in practice.
                      While in Python, the most usual idiom for
                      growing lists is appending to their end, the
                      most usual idiom in Emacs Lisp to grow a list
                      is by cons'ing new items at its
                      beginning:</p>
                      <pre class="literal-block">(setq accumulator (cons 'new-item accumulator))
</pre>

                      <p>or more simply:</p>
                      <pre class="literal-block">(push 'new-item accumulator)
</pre>

                      <p>So, in case speed is especially important
                      and many modifications happen in a row on the
                      same side, while order of elements ought to
                      be preserved, some <tt class="docutils literal">(nreverse <span class="pre">...)</span></tt> on the Emacs Lisp side
                      or <tt class="docutils literal">.reverse()</tt> on the
                      Python side might be needed. Surely, proper
                      lists in Emacs Lisp and lists in Python are
                      the normal structure for which length is
                      easily modified.</p>

                      <p>We cannot so easily change the size of a
                      vector, the same as it is a bit more of a
                      stunt to <em>modify</em> a tuple. The shape
                      of these objects is fixed. Mapping vectors to
                      tuples, which is admittedly strange, will
                      only be done if the Python side requests an
                      expanded copy, otherwise an opaque Emacs Lisp
                      object is seen in Python. In the other
                      direction, whenever an Emacs Lisp vector is
                      needed, one has to write <tt class="docutils literal">tuple(python_list)</tt>
                      while transmitting the object. Such
                      transmissions are most probably to be
                      unusual, as people are not going to blindly
                      transmit whole big structures back and forth
                      between Emacs and Python, they would rather
                      do it once in a while only, and do only local
                      modifications afterwards. The infrequent
                      casting to <strong class="code">tuple</strong> for getting an Emacs
                      Lisp vector seems to suggest that we did a
                      reasonable compromise.</p>

                      <p>In Python, both tuples and lists have O(1)
                      access, so there is no real speed
                      consideration there. Emacs Lisp is different:
                      vectors have O(1) access while lists have
                      O(N) access. The rigidity of Emacs Lisp
                      vectors is such that people do not resort to
                      vectors unless there is a speed issue, so in
                      real Emacs Lisp practice, vectors are used
                      rather parsimoniously. So much, in fact, that
                      Emacs Lisp vectors are overloaded for what
                      they are not meant: for example, very small
                      vectors are used to represent X events in
                      key-maps, programmers only want to test
                      vectors for their type, or users just like
                      bracketed syntax. The speed of access is
                      hardly an issue then.</p>
                    </div>

                    <div class="section" id="opaque-objects">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id19">3.4&nbsp;&nbsp;&nbsp;Opaque objects</a></h2>

                      <div class="section" id="emacs-lisp-handles">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id20">3.4.1&nbsp;&nbsp;&nbsp;Emacs Lisp handles</a></h3>

                        <p>When a Python function is called from
                        Emacs Lisp, the function arguments have
                        already been converted to Python types from
                        Emacs Lisp types and the function result is
                        going to be converted back to Emacs
                        Lisp.</p>

                        <p>Several Emacs Lisp objects do not have
                        Python equivalents, like for Emacs windows,
                        buffers, markers, overlays, etc. It is
                        nevertheless useful to pass them to Python
                        functions, hoping that these Python
                        functions will <em>operate</em> on these
                        Emacs Lisp objects. Of course, the Python
                        side may not itself modify such objects, it
                        has to call for Emacs services to do so.
                        Emacs Lisp handles are a mean to ease this
                        communication.</p>

                        <p>Whenever an Emacs Lisp object may not be
                        converted to a Python object, an Emacs Lisp
                        handle is created and used instead.
                        Whenever that Emacs Lisp handle is returned
                        into Emacs Lisp from a Python function, or
                        is used as an argument to an Emacs Lisp
                        function from Python, the original Emacs
                        Lisp object behind the Emacs Lisp handle is
                        automatically retrieved.</p>

                        <p>Emacs Lisp handles are either instances
                        of the internal <strong class="code">Lisp</strong> class, or of one of
                        its subclasses. If <em class="var">OBJECT</em> is an Emacs Lisp handle,
                        and if the underlying Emacs Lisp object is
                        an Emacs Lisp sequence, then whenever
                        <tt class="docutils literal">OBJECT[INDEX]</tt>,
                        <tt class="docutils literal">OBJECT[INDEX]
                        = VALUE</tt> and <tt class="docutils literal">len(OBJECT)</tt> are
                        meaningful, these may be used to fetch or
                        alter an element of the sequence directly
                        in Emacs Lisp space. Also, if <em class="var">OBJECT</em> corresponds to an Emacs
                        Lisp function, <tt class="docutils literal">OBJECT(ARGUMENTS)</tt>
                        may be used to apply the Emacs Lisp
                        function over the given arguments. Since
                        arguments have been evaluated the Python
                        way on the Python side, it would be
                        conceptual overkill evaluating them again
                        the Emacs Lisp way on the Emacs Lisp side,
                        so Pymacs manage to quote arguments for
                        defeating Emacs Lisp evaluation. The same
                        logic applies the other way around.</p>

                        <p>Emacs Lisp handles have a <tt class="docutils literal">value()</tt> method,
                        which merely returns self. They also have a
                        <tt class="docutils literal">copy()</tt>
                        method, which tries to <em>open the
                        box</em> if possible. Emacs Lisp proper
                        lists are turned into Python lists, Emacs
                        Lisp vectors are turned into Python tuples.
                        Then, modifying the structure of the copy
                        on the Python side has no effect on the
                        Emacs Lisp side.</p>

                        <p>For Emacs Lisp handles, <tt class="docutils literal">str()</tt> returns an
                        Emacs Lisp representation of the handle
                        which should be <strong class="code">eq</strong> to the original object
                        if read back and evaluated in Emacs Lisp.
                        <tt class="docutils literal">repr()</tt>
                        returns a Python representation of the
                        expanded Emacs Lisp object. If that Emacs
                        Lisp object has an Emacs Lisp
                        representation which Emacs Lisp could read
                        back, then <tt class="docutils literal">repr()</tt> value is
                        such that it could be read back and
                        evaluated in Python as well, this would
                        result in another object which is
                        <strong class="code">equal</strong> to the
                        original, but not necessarily
                        <strong class="code">eq</strong>.</p>
                      </div>

                      <div class="section" id="python-handles">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id21">3.4.2&nbsp;&nbsp;&nbsp;Python handles</a></h3>

                        <p>The same as Emacs Lisp handles are
                        useful for handling Emacs Lisp objects on
                        the Python side, Python handles are useful
                        for handling Python objects on the Emacs
                        Lisp side.</p>

                        <p>Many Python objects do not have direct
                        Emacs Lisp equivalents, including long
                        integers, complex numbers, modules,
                        classes, instances and surely a lot of
                        others. When such are being transmitted to
                        the Emacs Lisp side, Pymacs use Python
                        handles. These are automatically recovered
                        into the original Python objects whenever
                        transmitted back to Python, either as
                        arguments to a Python function, as the
                        Python function itself, or as the return
                        value of an Emacs Lisp function called from
                        Python.</p>

                        <p>The objects represented by these Python
                        handles may be inspected or modified using
                        the basic library of Python functions. For
                        example, in:</p>
                        <pre class="literal-block">(pymacs-exec "import re")
(setq matcher (pymacs-eval "re.compile('PATTERN').match"))
(pymacs-call matcher ARGUMENT)
</pre>

                        <p>the <strong class="code">setq</strong>
                        line above could be decomposed into:</p>
                        <pre class="literal-block">(setq compiled (pymacs-eval "re.compile('PATTERN')")
      matcher (pymacs-call "getattr" compiled "match"))
</pre>

                        <p>This example shows that one may use
                        <strong class="code">pymacs-call</strong>
                        with <strong class="code">getattr</strong>
                        as the function, to get a wanted attribute
                        for a Python object.</p>
                      </div>
                    </div>
                  </div>

                  <div class="section" id="usage-on-the-emacs-lisp-side">
                    <h1><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id22">4&nbsp;&nbsp;&nbsp;Usage on the Emacs Lisp
                    side</a></h1>

                    <div class="section" id="special-emacs-lisp-functions">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id23">4.1&nbsp;&nbsp;&nbsp;Special Emacs Lisp
                      functions</a></h2>

                      <p>Pymacs is mainly launched and used through
                      a few special functions, among all those
                      added by Pymacs for Emacs Lisp. These few
                      imported functions are listed and detailed in
                      the following subsections. They really are
                      the preferred way to call Python services
                      with Pymacs.</p>

                      <p>Even then, we do not expect that
                      <strong class="code">pymacs-exec</strong>,
                      <strong class="code">pymacs-eval</strong>,
                      <strong class="code">pymacs-call</strong> or
                      <strong class="code">pymacs-apply</strong>
                      will be much used, if ever, in most Pymacs
                      applications. In practice, the Emacs Lisp
                      side of a Pymacs application might call
                      <strong class="code">pymacs-load</strong> a
                      few times for linking into the Python
                      modules, with the indirect effect of defining
                      trampoline functions for these modules on the
                      Emacs Lisp side, which can later be called
                      like usual Emacs Lisp functions.</p>

                      <div class="section" id="pymacs-exec">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id24">4.1.1&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-exec</strong></a></h3>

                        <p>Function <tt class="docutils literal"><span class="pre">(pymacs-exec</span> TEXT)</tt> gets
                        <em class="var">TEXT</em> executed as a
                        Python statement, and its value is always
                        <strong class="code">nil</strong>. So, this
                        function may only be useful because of its
                        possible side effects on the Python
                        side.</p>

                        <p>This function may also be called
                        interactively:</p>
                        <pre class="literal-block">M-x pymacs-exec RET TEXT RET
</pre>
                      </div>

                      <div class="section" id="pymacs-eval">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id25">4.1.2&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-eval</strong></a></h3>

                        <p>Function <tt class="docutils literal"><span class="pre">(pymacs-eval</span> TEXT)</tt> gets
                        <em class="var">TEXT</em> evaluated as a
                        Python expression, and returns the value of
                        that expression converted back to Emacs
                        Lisp.</p>

                        <p>This function may also be called
                        interactively:</p>
                        <pre class="literal-block">M-x pymacs-eval RET TEXT RET
</pre>
                      </div>

                      <div class="section" id="pymacs-call">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id26">4.1.3&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-call</strong></a></h3>

                        <p>Function <tt class="docutils literal"><span class="pre">(pymacs-call</span> FUNCTION
                        <span class="pre">ARGUMENT...)</span></tt>
                        will get Python to apply the given
                        <em class="var">FUNCTION</em> over zero or
                        more <em class="var">ARGUMENT</em>.
                        <em class="var">FUNCTION</em> is either a
                        string holding Python source code for a
                        function (like a mere name, or even an
                        expression), or else, a Python handle
                        previously received from Python, and
                        hopefully holding a callable Python object.
                        Each <em class="var">ARGUMENT</em> gets
                        separately converted to Python before the
                        function is called. <strong class="code">pymacs-call</strong> returns the
                        resulting value of the function call,
                        converted back to Emacs Lisp.</p>
                      </div>

                      <div class="section" id="pymacs-apply">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id27">4.1.4&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-apply</strong></a></h3>

                        <p>Function <tt class="docutils literal"><span class="pre">(pymacs-apply</span> FUNCTION
                        ARGUMENTS)</tt> will get Python to apply
                        the given <em class="var">FUNCTION</em>
                        over the given <em class="var">ARGUMENTS</em>. <em class="var">ARGUMENTS</em> is a list containing
                        all arguments, or <strong class="code">nil</strong> if there is none.
                        Besides arguments being bundled together
                        instead of given separately, the function
                        acts pretty much like <strong class="code">pymacs-call</strong>.</p>
                      </div>

                      <div class="section" id="pymacs-load">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id28">4.1.5&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-load</strong></a></h3>

                        <p>Function <tt class="docutils literal"><span class="pre">(pymacs-load</span> MODULE
                        PREFIX)</tt> imports the Python <em class="var">module</em> into Emacs Lisp space.
                        <em class="var">MODULE</em> is the name of
                        the file containing the module, without any
                        <tt class="file docutils literal">.py</tt>
                        or <tt class="file docutils literal">.pyc</tt>
                        extension. If the directory part is omitted
                        in <em class="var">MODULE</em>, the module
                        will be looked into the current Python
                        search path. Dot notation may be used when
                        the module is part of a package. Each
                        top-level function in the module produces a
                        trampoline function in Emacs Lisp having
                        the same name, except that underlines in
                        Python names are turned into dashes in
                        Emacs Lisp, and that <em class="var">PREFIX</em> is uniformly added before
                        the Emacs Lisp name (as a way to avoid name
                        clashes). <em class="var">PREFIX</em> may
                        be omitted, in which case it defaults to
                        base name of <em class="var">MODULE</em>
                        with underlines turned into dashes, and
                        followed by a dash.</p>

                        <p>Note that <strong class="code">pymacs-load</strong> has the effect
                        of declaring the module variables and
                        methods on the Emacs Lisp side, but it does
                        <em>not</em> declare anything on the Python
                        side. Of course, Python imports the module
                        before making it available for Emacs, but
                        there is no Pymacs ready variable on the
                        Python side holding that module. If you
                        need to import <em class="var">MODULE</em>
                        in a variable on the Python side, the
                        proper incantation is <tt class="docutils literal"><span class="pre">(pymacs-exec</span> "import
                        MODULE")</tt>. And of course, this latter
                        statement does not declare anything on the
                        Emacs Lisp side.</p>

                        <p>Whenever <strong class="code">pymacs_load_hook</strong> is defined
                        in the loaded Python module, <strong class="code">pymacs-load</strong> calls it
                        without arguments, but before creating the
                        Emacs view for that module. So, the
                        <strong class="code">pymacs_load_hook</strong> function
                        may create new definitions or even add
                        <strong class="code">interaction</strong>
                        attributes to functions.</p>

                        <p>The return value of a successful
                        <strong class="code">pymacs-load</strong>
                        is the module object. An optional third
                        argument, <em class="var">noerror</em>,
                        when given and not <strong class="code">nil</strong>, will have
                        <strong class="code">pymacs-load</strong>
                        to return <strong class="code">nil</strong>
                        instead of raising an error, if the Python
                        module could not be found.</p>

                        <p>When later calling one of these
                        trampoline functions, all provided
                        arguments are converted to Python and
                        transmitted, and the function return value
                        is later converted back to Emacs Lisp. It
                        is left to the Python side to check for
                        argument consistency. However, for an
                        interactive function, the interaction
                        specification drives some checking on the
                        Emacs Lisp side. Currently, there is no
                        provision for collecting keyword arguments
                        in Emacs Lisp.</p>

                        <p>This function may also be called
                        interactively:</p>
                        <pre class="literal-block">M-x pymacs-load RET MODULE RET PREFIX RET
</pre>

                        <p>If you find yourself using
                        <strong class="code">pymacs-call</strong> a
                        lot for builtin Python functions, you might
                        rather elect to import all Python builtin
                        functions and definitions directly into
                        Emacs Lisp space, and call them directly
                        afterwards. Here is a recipe (use the first
                        line for Python 2, or the second line for
                        Python 3):</p>
                        <pre class="literal-block">M-x pymacs-load RET __builtin__ RET py- RET
M-x pymacs-load RET builtins RET py- RET
</pre>

                        <p>After such a command, calling the
                        function <tt class="docutils literal"><span class="pre">py-getattr</span></tt>, say, with an
                        opaque Python object and with a string
                        naming an attribute, returns the value of
                        that attribute for that object.</p>
                      </div>
                    </div>

                    <div class="section" id="special-emacs-lisp-variables">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id29">4.2&nbsp;&nbsp;&nbsp;Special Emacs Lisp
                      variables</a></h2>

                      <p>Users could alter the inner working of
                      Pymacs through a few variables, these are all
                      documented here. Except for <strong class="code">pymacs-python-command</strong> and
                      <strong class="code">pymacs-load-path</strong>, which
                      should be set before calling any Pymacs
                      function, the value of these variables can be
                      changed at any time.</p>

                      <div class="section" id="pymacs-python-command">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id30">4.2.1&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-python-command</strong></a></h3>

                        <p>This variable is initialized with the
                        Python executable that was used at
                        installation time. It tells Emacs about the
                        Python interpreter to launch far starting
                        the Pymacs helper. The value of this
                        variable may be overridden by setting the
                        <tt class="docutils literal">PYMACS_PYTHON</tt>
                        environment variable, yet in practice, for
                        newer versions of Pymacs, this is rarely
                        needed.</p>

                        <p>While the Python part of Pymacs is
                        pre-processed and yields different sources
                        for Python 2 and Python 3 (among other
                        possibilities), the Emacs part of Pymacs is
                        mostly configured at run time for various
                        Emacs versions, so the same Emacs source is
                        likely to work unaltered, would it be for
                        different versions of Emacs and for
                        different versions of Python. So it makes
                        sense, at least in some special
                        circumstances, giving the capability of
                        selecting a specific Python interpreter by
                        programmatical means within Emacs.</p>
                      </div>

                      <div class="section" id="pymacs-load-path">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id31">4.2.2&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-load-path</strong></a></h3>

                        <p>Users might want to use special
                        directories for holding their Python
                        modules, when these modules are meant to be
                        used from Emacs. Best is to preset
                        <strong class="code">pymacs-load-path</strong>,
                        <strong class="code">nil</strong> by
                        default, to a list of these directory
                        names. (Tilde expansions and such occur
                        automatically.)</p>

                        <p>Here is how it works. The first time
                        Pymacs is needed from Emacs, a Pymacs
                        helper is automatically started as an Emacs
                        subprocess, and given as arguments all
                        strings in the <strong class="code">pymacs-load-path</strong> list.
                        These arguments are added at the beginning
                        of <strong class="code">sys.path</strong>,
                        or moved at the beginning if they were
                        already on <strong class="code">sys.path</strong>. So in practice,
                        nothing is removed from <strong class="code">sys.path</strong>.</p>
                      </div>

                      <div class="section" id="pymacs-trace-transit">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id32">4.2.3&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-trace-transit</strong></a></h3>

                        <p>The <strong class="code">*Pymacs*</strong> buffer, within
                        Emacs, holds a trace of transactions
                        between Emacs and Python. When
                        <strong class="code">pymacs-trace-transit</strong> is
                        <strong class="code">nil</strong>, the
                        buffer only holds the last bi-directional
                        transaction (a request and a reply). In
                        this case, it gets erased before each and
                        every transaction. If that variable is
                        <strong class="code">t</strong>, all
                        transactions are kept. This could be useful
                        for debugging, but the drawback is that
                        this buffer could grow big over time, to
                        the point of diminishing Emacs performance.
                        As a compromise, that variable may also be
                        a cons cell of integers <tt class="docutils literal">(KEEP . LIMIT)</tt>, in
                        which case the buffer is reduced to
                        approximately <em class="var">KEEP</em>
                        bytes whenever its size exceeds <em class="var">LIMIT</em> bytes, by deleting an
                        integral number of lines from its
                        beginning. The default setting for
                        <strong class="code">pymacs-trace-transit</strong> is
                        <tt class="docutils literal">(5000 .
                        30000)</tt>.</p>
                      </div>

                      <div class="section" id="pymacs-forget-mutability">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id33">4.2.4&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-forget-mutability</strong></a></h3>

                        <p>The default behaviour of Pymacs is to
                        transmit Emacs Lisp objects to Python in
                        such a way that they are fully modifiable
                        from the Python side, would it mean
                        triggering Emacs Lisp functions to act on
                        them. When <strong class="code">pymacs-forget-mutability</strong> is
                        not <strong class="code">nil</strong>, the
                        behaviour is changed, and the flexibility
                        is lost. Pymacs then tries to expand proper
                        lists and vectors as full copies when
                        transmitting them on the Python side. This
                        variable, seen as a user setting, is best
                        left to <strong class="code">nil</strong>.
                        It may be temporarily overridden within
                        some functions, when deemed useful.</p>

                        <p>There is no corresponding variable from
                        objects transmitted to Emacs from Python.
                        Pymacs automatically expands what gets
                        transmitted. Mutability is preserved only
                        as a side-effect of not having a natural
                        Emacs Lisp representation for the Python
                        object. This asymmetry is on purpose, yet
                        debatable. Maybe Pymacs could have a
                        variable telling that mutability is
                        important for Python objects? That would
                        give Pymacs users the capability of
                        restoring the symmetry somewhat, yet so
                        far, in our experience, this has never been
                        needed.</p>
                      </div>

                      <div class="section" id="pymacs-mutable-strings">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id34">4.2.5&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-mutable-strings</strong></a></h3>

                        <p>Strictly speaking, Emacs Lisp strings
                        are mutable. Yet, it does not come
                        naturally to a Python programmer to modify
                        a string <em>in-place</em>, as Python
                        strings are never mutable. When
                        <strong class="code">pymacs-mutable-strings</strong> is
                        <strong class="code">nil</strong>, which is
                        the default setting, Emacs Lisp strings are
                        transmitted to Python as Python strings,
                        and so, loose their mutability. Moreover,
                        text properties are not reflected on the
                        Python side. But if that variable is not
                        <strong class="code">nil</strong>, Emacs
                        Lisp strings are rather passed as Emacs
                        Lisp handles. This variable is ignored
                        whenever <strong class="code">pymacs-forget-mutability</strong> is
                        set.</p>
                      </div>

                      <div class="section" id="timeout-variables">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id35">4.2.6&nbsp;&nbsp;&nbsp;Timeout variables</a></h3>

                        <p>Emacs needs to protect itself a bit, in
                        case the Pymacs service program, which
                        handles the Python side of requests, would
                        not start correctly, or maybe later die
                        unexpectedly. So, whenever Emacs reads data
                        coming from that program, it sets a time
                        limit, and take some action whenever that
                        time limit expires. All times are expressed
                        in seconds.</p>

                        <p>The <strong class="code">pymacs-timeout-at-start</strong>
                        variable defaults to 30 seconds, this time
                        should only be increased if a given machine
                        is so heavily loaded that the Pymacs
                        service program has not enough of 30
                        seconds to start, in which case Pymacs
                        refuses to work, with an appropriate
                        message in the mini buffer.</p>

                        <p>The two remaining timeout variables
                        almost never need to be changed in
                        practice. When Emacs is expecting a reply
                        from Python, it might repeatedly check the
                        status of the Pymacs service program when
                        that reply is not received fast enough,
                        just to make sure that this program did not
                        die. The <strong class="code">pymacs-timeout-at-reply</strong>
                        variable, which defaults to 5, says how
                        many seconds to wait without checking,
                        while expecting the first line of a reply.
                        The <strong class="code">pymacs-timeout-at-line</strong>
                        variable, which defaults to 2, says how
                        many seconds to wait without checking,
                        while expecting a line of the reply after
                        the first.</p>
                      </div>

                      <div class="section" id="pymacs-auto-restart">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id36">4.2.7&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-auto-restart</strong></a></h3>

                        <p>The Pymacs helper process is started as
                        soon as it is needed, and gets associated
                        with the <strong class="code">*Pymacs*</strong> buffer. When that
                        buffer is killed, as it occurs
                        automatically whenever the Emacs session is
                        ending, the Pymacs helper process is killed
                        as well. Any other disappearance of the
                        helper is unexpected, and might be the
                        consequence of some error in the Python
                        side of the user application (or a Pymacs
                        bug, maybe!).</p>

                        <p>When the Pymacs helper dies, all useful
                        Python objects it might contain also die
                        with it. So, after an unexpected death,
                        there might now exist dangling references
                        in Emacs Lisp space towards vanished Python
                        objects, and using these references may be
                        fatal to the application. When the Pymacs
                        helper dies, the safest thing to do is
                        stopping all Pymacs functionality and even
                        exiting Emacs. On the other hand, it is not
                        always practical having to restart
                        everything in such cases: the user knows
                        best, and is the one who ultimately
                        decides.</p>

                        <p>The Pymacs helper death is detected at
                        the time a new Pymacs request gets
                        initiated from the Emacs side. Pymacs could
                        not do much without a Pymacs helper, so it
                        has either to restart a new Pymacs helper,
                        or abort the Pymacs request. The variable
                        <strong class="code">pymacs-auto-restart</strong>
                        controls how this is done. The possible
                        values are:</p>

                        <blockquote>
                          <ul class="simple">
                            <li><tt class="docutils literal">nil</tt> — the
                            Pymacs request is unconditionally
                            aborted,</li>

                            <li><tt class="docutils literal">t</tt>
                            — a new Pymacs helper is silently
                            launched, and the previous helper death
                            might well go unnoticed,</li>

                            <li><tt class="docutils literal">'ask</tt> — the user
                            interactively decides whether to
                            restart the Pymacs helper or not. This
                            is the default value.</li>
                          </ul>
                        </blockquote>
                      </div>

                      <div class="section" id="pymacs-dreadful-zombies">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id37">4.2.8&nbsp;&nbsp;&nbsp;<strong class="code">pymacs-dreadful-zombies</strong></a></h3>

                        <p>When a Pymacs helper gets restarted in a
                        given Emacs session, brand new Python
                        objects may be created within that new
                        helper. There is not enough information
                        kept on the Emacs Lisp side for the new
                        Pymacs helper to recreate the useful Python
                        objects which disappeared. However, there
                        is enough machinery to recover all their
                        slot numbers (all references to opaque
                        Python objects from Emacs Lisp space are
                        transmitted in form of object slot
                        numbers).</p>

                        <p>The new Pymacs helper is given the list
                        of all previous slot numbers still
                        referenced from the Emacs side, and is then
                        careful at never allocating a new Python
                        object using an old slot number, as this
                        might possibly create fatal confusion. All
                        the previous slots are initialized with
                        so-called <em>zombies</em> on the Python
                        side. If Emacs later calls a vanished
                        Python object, this merely awakes its
                        zombie, which will then make some noise,
                        then fall asleep again. The noise has the
                        form of a diagnostic within the <tt class="docutils literal">*Messages*</tt> buffer,
                        sometimes visible in the mini-buffer too,
                        at least when the mini-buffer is not
                        simultaneously used for some other
                        purpose.</p>

                        <p>Zombies get more dreadful if
                        <strong class="code">pymacs-dreadful-zombies</strong> is
                        set to a non-<strong class="code">nil</strong> value. In this case,
                        calling a vanished Python object raises an
                        error that will eventually interrupt the
                        current computation. Such a behaviour might
                        be useful for debugging purposes, or for
                        making sure that no call to a vanished
                        Python object goes unnoticed.</p>

                        <p>In previous Pymacs releases, zombies
                        were always dreadful, under the assumption
                        that calling a vanished object is a real
                        error. However, it could cause irritation
                        in some circumstances, like when associated
                        with frequently triggered Emacs Lisp hook
                        functions. That's why that, by default,
                        zombies have been finally turned into more
                        innocuous beings!</p>
                      </div>
                    </div>
                  </div>

                  <div class="section" id="usage-on-the-python-side">
                    <h1><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id38">5&nbsp;&nbsp;&nbsp;Usage on the Python side</a></h1>

                    <div class="section" id="python-setup">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id39">5.1&nbsp;&nbsp;&nbsp;Python setup</a></h2>

                      <p>For Python modules meant to be used from
                      Emacs and which receive nothing but Emacs
                      <strong class="code">nil</strong>, numbers or
                      strings, or return nothing but Python
                      <strong class="code">None</strong>, numbers
                      or strings, then Pymacs requires little or no
                      setup. Otherwise, use <tt class="docutils literal">from Pymacs import
                      lisp</tt> at the start of your module. If you
                      need more Pymacs features, like the
                      <strong class="code">Let</strong> class, then
                      write <tt class="docutils literal">from
                      Pymacs import lisp, Let</tt>.</p>

                      <p>The Pymacs helper runs Python code to
                      serve the Emacs side, and it is blocked
                      waiting until Emacs sends a request. Until
                      the Pymacs helper returns a reply, Emacs is
                      blocked in turn, yet fully listening to serve
                      eventual Python sub-requests, etc. So, either
                      Emacs or the Pymacs helper is active at a
                      given instant, but never both at once.</p>

                      <p>Unless Emacs has sent a request to the
                      Pymacs helper and is expecting a reply, it is
                      just not listening to receive Python
                      requests. So, any other Python thread may not
                      asynchronously use Pymacs to get Emacs
                      services. The design of the Python
                      application should be such that the
                      communication is always be channelled from
                      the main Python thread.</p>

                      <p>When Pymacs starts, all process signals
                      are inhibited on the Python side. Yet,
                      <strong class="code">SIGINT</strong> gets
                      re-enabled while running user functions. If
                      the user elects to reactivate some other
                      signal in her Python code, she should do so
                      as to not damage or severe the communication
                      protocol.</p>
                    </div>

                    <div class="section" id="emacs-lisp-symbols">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id40">5.2&nbsp;&nbsp;&nbsp;Emacs Lisp symbols</a></h2>

                      <p><strong class="code">lisp</strong> is a
                      special object which has useful built-in
                      magic. Its attributes do nothing but
                      represent Emacs Lisp symbols, created on the
                      fly as needed (symbols also have their
                      built-in magic).</p>

                      <p>As special cases, <tt class="docutils literal">lisp.nil</tt> or
                      <tt class="docutils literal"><span class="pre">lisp["nil"]</span></tt> are the same as
                      <strong class="code">None</strong>, and
                      <tt class="docutils literal">lisp.t</tt> or
                      <tt class="docutils literal"><span class="pre">lisp["t"]</span></tt> are the same as
                      <strong class="code">True</strong>.
                      Otherwise, both <tt class="docutils literal">lisp.SYMBOL</tt> and
                      <tt class="docutils literal">lisp[STRING]</tt> yield
                      objects of the internal <strong class="code">Symbol</strong> type. These are
                      genuine Python objects, that could be
                      referred to by simple Python variables. One
                      may write <tt class="docutils literal">quote
                      = lisp.quote</tt>, for example, and use
                      <tt class="docutils literal">quote</tt>
                      afterwards to mean that Emacs Lisp symbol. If
                      a Python function received an Emacs Lisp
                      symbol as an argument, it can check with
                      <tt class="docutils literal">==</tt> if that
                      argument is <tt class="docutils literal">lisp.never</tt> or
                      <tt class="docutils literal">lisp.ask</tt>,
                      say. A Python function may well choose to
                      return some symbol, like <tt class="docutils literal">lisp.always</tt>.</p>

                      <p>In Python, writing <tt class="docutils literal">lisp.SYMBOL = VALUE</tt>
                      or <tt class="docutils literal">lisp[STRING]
                      = VALUE</tt> does assign <em class="var">VALUE</em> to the corresponding symbol
                      in Emacs Lisp space. Beware that in such
                      cases, the <tt class="docutils literal">lisp.</tt> prefix may not
                      be spared. After <tt class="docutils literal">result = lisp.result</tt>,
                      one cannot hope that a later <tt class="docutils literal">result = 3</tt> will have
                      any effect in the Emacs Lisp space: this
                      would merely change the Python variable
                      <tt class="docutils literal">result</tt>,
                      which was a reference to a <strong class="code">Symbol</strong> instance, so it is now
                      a reference to the number 3.</p>

                      <p>The <strong class="code">Symbol</strong>
                      class has <tt class="docutils literal">value()</tt> and
                      <tt class="docutils literal">copy()</tt>
                      methods. One can use either <tt class="docutils literal">lisp.SYMBOL.value()</tt>
                      or <tt class="docutils literal">lisp.SYMBOL.copy()</tt> to
                      access the Emacs Lisp value of a symbol,
                      after conversion to some Python object, of
                      course. However, if <tt class="docutils literal">value()</tt> would have
                      given an Emacs Lisp handle, <tt class="docutils literal">lisp.SYMBOL.copy()</tt>
                      has the effect of <tt class="docutils literal"><span class="pre">lisp.SYMBOL.value().copy()</span></tt>,
                      that is, it returns the value of the symbol
                      as opened as possible.</p>

                      <p>A symbol may also be used as if it was a
                      Python function, in which case it really
                      names an Emacs Lisp function that should be
                      applied over the following function
                      arguments. The result of the Emacs Lisp
                      function becomes the value of the call, with
                      all due conversions of course.</p>
                    </div>

                    <div class="section" id="dynamic-bindings">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id41">5.3&nbsp;&nbsp;&nbsp;Dynamic bindings</a></h2>

                      <p>As Emacs Lisp uses dynamic bindings, it is
                      common that Emacs Lisp programs use
                      <strong class="code">let</strong> for
                      temporarily setting new values for some Emacs
                      Lisp variables having global scope. These
                      variables recover their previous value
                      automatically when the <strong class="code">let</strong> gets completed, even if
                      an error occurs which interrupts the normal
                      flow of execution.</p>

                      <p>Pymacs has a <strong class="code">Let</strong> class to represent such
                      temporary settings. Suppose for example that
                      you want to recover the value of <tt class="docutils literal">lisp.mark()</tt> when the
                      transient mark mode is active on the Emacs
                      Lisp side. One could surely use <tt class="docutils literal">lisp.mark(True)</tt> to
                      <em>force</em> reading the mark in such
                      cases, but for the sake of illustration,
                      let's ignore that, and temporarily deactivate
                      transient mark mode instead. This could be
                      done this way:</p>
                      <pre class="literal-block">try:
    let = Let()
    let.push(transient_mark_mode=None)
    ... USER CODE ...
finally:
    let.pop()
</pre>

                      <p><tt class="docutils literal">let.push()</tt> accepts
                      any number of keywords arguments. Each
                      keyword name is interpreted as an Emacs Lisp
                      symbol written the Pymacs way, with
                      underlines. The value of that Emacs Lisp
                      symbol is saved on the Python side, and the
                      value of the keyword becomes the new
                      temporary value for this Emacs Lisp symbol. A
                      later <tt class="docutils literal">let.pop()</tt> restores
                      the previous value for all symbols which were
                      saved together at the time of the
                      corresponding <tt class="docutils literal">let.push()</tt>. There may
                      be more than one <tt class="docutils literal">let.push()</tt> call for a
                      single <strong class="code">Let</strong>
                      instance, they stack within that instance.
                      Each <tt class="docutils literal">let.pop()</tt> will undo
                      one and only one <tt class="docutils literal">let.push()</tt> from the
                      stack, in the reverse order or the
                      pushes.</p>

                      <p>A single call to <tt class="docutils literal">let.pops()</tt>
                      automatically does all pending <tt class="docutils literal">let.pop()</tt> at once, in
                      the correct reverse order. When the
                      <strong class="code">Let</strong> instance
                      disappears, either because the programmer
                      does <tt class="docutils literal">del
                      let</tt> or <tt class="docutils literal">let
                      = None</tt>, or just because the Python
                      <strong class="code">let</strong> variable
                      goes out of scope, <tt class="docutils literal">let.pops()</tt> gets
                      executed under the scene, so the
                      <strong class="code">try</strong>/<strong class="code">finally</strong> statement may be
                      omitted in practice. For this omission to
                      work flawlessly, the programmer should be
                      careful at not keeping extra references to
                      the <strong class="code">Let</strong>
                      instance.</p>

                      <p>The constructor call <tt class="docutils literal">let = Let()</tt> also has
                      an implied initial <tt class="docutils literal">.push()</tt> over all
                      given arguments, given there is any, so the
                      explicit <tt class="docutils literal">let.push()</tt> may be
                      omitted as well. In practice, this sums up
                      and the above code could be reduced to a
                      mere:</p>
                      <pre class="literal-block">let = Let(transient_mark_mode=None)
... USER CODE ...
</pre>

                      <p>Be careful at assigning the result of the
                      constructor to some Python variable.
                      Otherwise, the instance might disappear
                      immediately after having been created,
                      restoring the Emacs Lisp variable much too
                      soon.</p>

                      <p>Any variable to be bound with
                      <strong class="code">Let</strong> should have
                      been bound in advance on the Emacs Lisp side.
                      This restriction usually does no kind of
                      harm. Yet, it will likely be lifted in some
                      later version of Pymacs.</p>

                      <p>The <strong class="code">Let</strong>
                      class has other methods meant for some macros
                      which are common in Emacs Lisp programming,
                      in the spirit of <strong class="code">let</strong> bindings. These method
                      names look like <tt class="docutils literal">push_*</tt> or <tt class="docutils literal">pop_*</tt>, where Emacs
                      Lisp macros are <tt class="docutils literal"><span class="pre">save-*</span></tt>. One has to use the
                      matching <tt class="docutils literal">pop_*</tt> for undoing the
                      effect of a given <tt class="docutils literal">push_*</tt> rather than a
                      mere <tt class="docutils literal">.pop()</tt>: the Python
                      code is clearer, this also ensures that
                      things are undone in the proper order. The
                      same <strong class="code">Let</strong>
                      instance may use many <tt class="docutils literal">push_*</tt> methods, their
                      effects nest.</p>

                      <p><tt class="docutils literal">push_excursion()</tt> and
                      <tt class="docutils literal">pop_excursion()</tt> save
                      and restore the current buffer, point and
                      mark. <tt class="docutils literal">push_match_data()</tt> and
                      <tt class="docutils literal">pop_match_data()</tt> save
                      and restore the state of the last regular
                      expression match. <tt class="docutils literal">push_restriction()</tt>
                      and <tt class="docutils literal">pop_restriction()</tt>
                      save and restore the current narrowing
                      limits. <tt class="docutils literal">push_selected_window()</tt>
                      and <tt class="docutils literal">pop_selected_window()</tt>
                      save and restore the fact that a window holds
                      the cursor. <tt class="docutils literal">push_window_excursion()</tt>
                      and <tt class="docutils literal">pop_window_excursion()</tt>
                      save and restore the current window
                      configuration in the Emacs display.</p>

                      <p>As a convenience, <tt class="docutils literal">let.push()</tt> and all
                      other <tt class="docutils literal">push_*</tt> methods return
                      the <strong class="code">Let</strong>
                      instance. This helps chaining various
                      <tt class="docutils literal">push_*</tt>
                      right after the instance generation. For
                      example, one may write:</p>
                      <pre class="literal-block">let = Let().push_excursion()
if True:
    ... USER CODE ...
del let
</pre>

                      <p>The <tt class="docutils literal">if
                      True:</tt> (use <tt class="docutils literal">if 1:</tt> with older
                      Python releases, some people might prefer
                      writing <tt class="docutils literal">if
                      let:</tt> anyway), has the only goal of
                      indenting <em class="var">USER CODE</em>, so
                      the scope of the <strong class="code">let</strong> variable is made very
                      explicit. This is purely stylistic, and not
                      at all necessary. The last <tt class="docutils literal">del let</tt> might be
                      omitted in a few circumstances, for example
                      if the excursion lasts until the end of the
                      Python function.</p>
                    </div>

                    <div class="section" id="raw-emacs-lisp-expressions">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id42">5.4&nbsp;&nbsp;&nbsp;Raw Emacs Lisp
                      expressions</a></h2>

                      <p>Pymacs offers a device for evaluating a
                      raw Emacs Lisp expression, or a sequence of
                      such, expressed as a string. One merely uses
                      <strong class="code">lisp</strong> as a
                      function, like this:</p>
                      <pre class="literal-block">lisp('''
...
POSSIBLY-LONG-SEQUENCE-OF-LISP-EXPRESSIONS
...
''')
</pre>

                      <p>The Emacs Lisp value of the last or only
                      expression in the sequence becomes the value
                      of the <strong class="code">lisp</strong>
                      call, after conversion back to Python.</p>
                    </div>

                    <div class="section" id="user-interaction">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id43">5.5&nbsp;&nbsp;&nbsp;User interaction</a></h2>

                      <p>Emacs functions have the concept of user
                      interaction for completing the specification
                      of their arguments while being called. This
                      happens only when a function is interactively
                      called by the user, it does not happen when a
                      function is directly called by another. As
                      Python does not have a corresponding
                      facility, a bit of trickery was needed to
                      retrofit that facility on the Python
                      side.</p>

                      <p>After loading a Python module but prior to
                      creating an Emacs view for this module,
                      Pymacs decides whether loaded functions will
                      be interactively callable from Emacs, or not.
                      Whenever a function has an <strong class="code">interaction</strong> attribute, this
                      attribute holds the Emacs interaction
                      specification for this function. The
                      specification is either another Python
                      function or a string. In the former case,
                      that other function is called without
                      arguments and should, maybe after having
                      consulted the user, return a list of the
                      actual arguments to be used for the original
                      function. In the latter case, the
                      specification string is used verbatim as the
                      argument to the <tt class="docutils literal">(interactive <span class="pre">...)</span></tt> function on the Emacs
                      side. To get a short reminder about how this
                      string is interpreted on the Emacs side, try
                      <tt class="docutils literal"><span class="pre">C-h</span> f interactive RET</tt>
                      within Emacs. Here is an example where an
                      empty string is used to specify that an
                      interactive has no arguments:</p>
                      <pre class="literal-block">from Pymacs import lisp

def hello_world():
    "`Hello world' from Python."
    lisp.insert("Hello from Python!")
hello_world.interaction = ''
</pre><!-- ` -->

                      <p>Versions of Python released before the
                      integration of PEP 232 do not allow users to
                      add attributes to functions, so there is a
                      fall-back mechanism. Let's presume that a
                      given function does not have an
                      <strong class="code">interaction</strong>
                      attribute as explained above. If the Python
                      module contains an <strong class="code">interactions</strong> global variable
                      which is a dictionary, if that dictionary has
                      an entry for the given function with a value
                      other than <strong class="code">None</strong>, that function is going
                      to be interactive on the Emacs side. Here is
                      how the preceding example should be written
                      for an older version of Python, or when
                      portability is at premium:</p>
                      <pre class="literal-block">from Pymacs import lisp
interactions = {}

def hello_world():
    "`Hello world' from Python."
    lisp.insert("Hello from Python!")
interactions[hello_world] = ''
</pre>

                      <p>One might wonder why we do not merely use
                      <tt class="docutils literal"><span class="pre">lisp.interactive(...)</span></tt> from
                      within Python. There is some magic in the
                      Emacs Lisp interpreter itself, looking for
                      that call <em>before</em> the function is
                      actually entered, this explains why
                      <tt class="docutils literal">(interactive
                      <span class="pre">...)</span></tt> has to
                      appear first in an Emacs Lisp <strong class="code">defun</strong>. Pymacs could try to
                      scan the already compiled form of the Python
                      code, seeking for <tt class="docutils literal">lisp.interactive</tt>, but
                      as the evaluation of <strong class="code">lisp.interactive</strong> arguments
                      could get arbitrarily complex, it would a
                      real challenge un-compiling that evaluation
                      into Emacs Lisp.</p>
                    </div>

                    <div class="section" id="key-bindings">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id44">5.6&nbsp;&nbsp;&nbsp;Key bindings</a></h2>

                      <p>An interactive function may be bound to a
                      key sequence.</p>

                      <p>To translate bindings like <tt class="docutils literal"><span class="pre">C-x</span> w</tt>, say, one might have
                      to know a bit more how Emacs Lisp processes
                      string escapes like <tt class="docutils literal"><span class="pre">\C-x</span></tt> or <tt class="docutils literal"><span class="pre">\M-\C-x</span></tt> in Emacs Lisp, and
                      emulate it within Python strings, since
                      Python does not have such escapes. <tt class="docutils literal"><span class="pre">\C-L</span></tt>, where L is an upper
                      case letter, produces a character which
                      ordinal is the result of subtracting 0x40
                      from ordinal of <tt class="docutils literal">L</tt>. <tt class="docutils literal">\M-</tt> has the ordinal
                      one gets by adding 0x80 to the ordinal of
                      following described character. So people can
                      use self-inserting non-ASCII characters,
                      <tt class="docutils literal">\M-</tt> is
                      given another representation, which is to
                      replace the addition of 0x80 by prefixing
                      with Escape, that is 0x1b. So <tt class="docutils literal"><span class="pre">\C-x</span></tt> in Emacs is <tt class="docutils literal">\x18</tt> in Python. This
                      is easily found, using an interactive Python
                      session, by giving it: <tt class="docutils literal"><span class="pre">chr(ord('X')</span> - <span class="pre">ord('A')</span> + 1)</tt>.</p>

                      <p>An easier way would be using the
                      <strong class="code">kbd</strong> function on
                      the Emacs Lisp side, like with <tt class="docutils literal"><span class="pre">lisp.kbd('C-x</span> w')</tt> or
                      <tt class="docutils literal"><span class="pre">lisp.kbd('M-&lt;f2&gt;')</span></tt>.</p>

                      <p>To bind the F1 key to the <strong class="code">helper</strong> function in some
                      <strong class="code">module</strong>:</p>
                      <pre class="literal-block">lisp.global_set_key((lisp.f1,), lisp.module_helper)
</pre>

                      <p><tt class="docutils literal">(item,)</tt>
                      is a Python tuple yielding an Emacs Lisp
                      vector. <tt class="docutils literal">lisp.f1</tt> translates to
                      the Emacs Lisp symbol <strong class="code">f1</strong>. So, Python <tt class="docutils literal">(lisp.f1,)</tt> is Emacs
                      Lisp <tt class="docutils literal">[f1]</tt>.
                      Keys like <tt class="docutils literal"><span class="pre">[M-f2]</span></tt> might require some
                      more ingenuity, one may write either
                      <tt class="docutils literal"><span class="pre">(lisp['M-f2'],)</span></tt> or
                      <tt class="docutils literal">(lisp.M_f2,)</tt> on the
                      Python side.</p>
                    </div>
                  </div>

                  <div class="section" id="debugging">
                    <h1><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id45">6&nbsp;&nbsp;&nbsp;Debugging</a></h1>

                    <p>Finding bugs in a program is an art, which
                    may be difficult enough already when there is a
                    single process and a single language. Pymacs
                    involves a part (usually short) written in
                    Emacs Lisp and another part (usually more
                    substantial) written in Python, each running in
                    their own process. Both processes communicate
                    which each other. Moreover, to get debugging
                    hints, Emacs is often the necessary door by
                    which the programming user may catch glimpses
                    on what is happening on both sides.</p>

                    <p>To effectively debug Pymacs code, one
                    benefits from having some familiarity with the
                    communication protocol, and also from knowing
                    how to observe both sides of this protocol at
                    once. The usual way is through the
                    <strong class="code">*Pymacs*</strong> buffer
                    within Emacs, which shows an Emacs view the
                    whole protocol. One may also view by forcing
                    the Pymacs helper to save a trace file, which
                    shows a Python view the whole protocol — unless
                    there are communication errors, this should
                    tell the same story as with the <strong class="code">*Pymacs*</strong> buffer. These few
                    topics are developed in the three following
                    sections. The remaining sections address more
                    specific issues about Emacs Lisp or Python
                    debugging.</p>

                    <div class="section" id="the-communication-protocol">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id46">6.1&nbsp;&nbsp;&nbsp;The communication
                      protocol</a></h2>

                      <p>The Pymacs communication protocol is
                      rather simple deep down, merely using
                      evaluation on arrival on both sides. All the
                      rest is recursion trickery over that simple
                      idea.</p>

                      <ul>
                        <li>
                          <p class="first">It is more easy to
                          generate than to parse. Moreover, Emacs
                          has a Lisp parser and Python has a Python
                          parser. So, when preparing a message to
                          the Pymacs helper, Emacs generates Python
                          code for Python to parse, and when
                          preparing a message for Emacs, Python
                          generates Emacs Lisp expressions for
                          Emacs to parse.</p>
                        </li>

                        <li>
                          <p class="first">Messages are exchanged
                          in strictly alternating directions (from
                          Python to Emacs, from Emacs to Python,
                          etc.), the first message being sent by
                          the Pymacs helper (from Python to Emacs)
                          just after it started, identifying the
                          current Pymacs version.</p>
                        </li>

                        <li>
                          <p class="first">Messages in both
                          directions have a similar envelope. Each
                          physical message has a prefix, the
                          message contents, and a newline. The
                          prefix starts with either <tt class="docutils literal">&lt;</tt> or
                          <tt class="docutils literal">&gt;</tt> to
                          mark the directionality, is followed by
                          the decimal expression of the contents
                          length counted in characters, and
                          terminates with a single horizontal tab.
                          The count excludes the prefix, but
                          includes the newline.</p>
                        </li>

                        <li>
                          <p class="first">In each direction,
                          messages are made up of two elements: an
                          action keyword and a single argument (yet
                          the argument may sometimes be complex).
                          As a special case, memory cleanup
                          messages from Python to Emacs use four
                          elements: the atom <strong class="code">free</strong>, a list of slot
                          numbers to free, and then the real action
                          and argument. This is because the cleanup
                          is delayed and piggy-backed over some
                          other message.</p>
                        </li>

                        <li>
                          <p class="first">For Emacs originated
                          messages, the action and the argument are
                          separated by a space. For Python
                          originated messages, the action and the
                          argument are made into a Lisp list.</p>
                        </li>

                        <li>
                          <p class="first">Most actions in the
                          following table are available in both
                          directions, unless noted. The first three
                          actions <em>start</em> a new level of
                          Pymacs evaluation, the two remaining
                          actions end the current level.</p>

                          <ul class="simple">
                            <li><strong class="code">eval</strong>
                            requests the evaluation of its
                            expression argument.</li>

                            <li><strong class="code">exec</strong>
                            requests the execution of its statement
                            argument (this may only be received on
                            the Python side).</li>

                            <li><strong class="code">expand</strong> requests the
                            opening of an Emacs Lisp structure
                            (this may only be received on the Emacs
                            side).</li>

                            <li><strong class="code">return</strong> represents the
                            normal reply to a request, the argument
                            holds the value to be returned
                            (<strong class="code">nil</strong> in
                            case of <strong class="code">exec</strong>).</li>

                            <li><strong class="code">raise</strong>
                            represents the error reply to a
                            request, the argument then holds a
                            diagnostic string.</li>
                          </ul>

                          <p>Python evaluation is done in the
                          context of the <strong class="code">Pymacs.pymacs</strong> module. On
                          the Emacs Lisp side, there is no concept
                          of module name spaces, so we internally
                          use the <tt class="docutils literal">pymacs-</tt> prefix as
                          an attempt to stay clean. Users should
                          ideally refrain from naming their Emacs
                          Lisp objects with a <tt class="docutils literal">pymacs-</tt>
                          prefix.</p>
                        </li>
                      </ul>

                      <p>The protocol may be fragile to
                      interruption requests, so it tries to
                      recognize each message action before
                      evaluation is attempted. The idea (not fully
                      implemented yet) is to make the protocol part
                      immune to interruptions, but to allow
                      evaluations themselves to be interrupted.</p>
                    </div>

                    <div class="section" id="the-pymacs-buffer">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id47">6.2&nbsp;&nbsp;&nbsp;The <strong class="code">*Pymacs*</strong> buffer</a></h2>

                      <p>Emacs and Python are two separate
                      processes (well, each may use more than one
                      process). Pymacs implements a simple
                      communication protocol between both, and does
                      whatever needed so the programmers do not
                      have to worry about details. The main
                      debugging tool is the communication buffer
                      between Emacs and Python, which is named
                      <strong class="code">*Pymacs*</strong>.</p>

                      <p>As it is sometimes helpful to understand
                      the communication protocol, it is briefly
                      explained here, using an artificially complex
                      example to do so. Consider (this example
                      assumes Python 2):</p>
                      <pre class="literal-block">(pymacs-eval "lisp('(pymacs-eval \"repr(2L**111)\")')")
"2596148429267413814265248164610048L"
</pre>

                      <p>Here, Emacs asks Python to ask Emacs to
                      ask Python for a simple bignum computation.
                      Note that Emacs does not natively know how to
                      handle big integers, nor has an internal
                      representation for them. This is why I use
                      the <strong class="code">repr</strong>
                      function, so Python returns a string
                      representation of the result, instead of the
                      result itself. Here is a trace for this
                      example. Imagine that Emacs stands on the
                      left and that Python stands on the right. The
                      <tt class="docutils literal">&lt;</tt>
                      character flags a message going from Python
                      to Emacs, while the <tt class="docutils literal">&gt;</tt> character flags
                      a message going from Emacs to Python. The
                      number gives the length of the message,
                      including the end of line. (Acute readers may
                      notice that the first number is incorrect, as
                      the version number gets replaced in the
                      example while this manual is being
                      produced.)</p>
                      <pre class="literal-block">&lt;22     (version "0.24-beta2")
&gt;43     eval lisp('(pymacs-eval "repr(2L**111)")')
&lt;45     (eval (progn (pymacs-eval "repr(2L**111)")))
&gt;19     eval repr(2L**111)
&lt;47     (return "2596148429267413814265248164610048L")
&gt;45     return "2596148429267413814265248164610048L"
&lt;47     (return "2596148429267413814265248164610048L")
</pre>

                      <p>Part of the protocol manages memory, and
                      this management generates some extra-noise in
                      the <strong class="code">*Pymacs*</strong>
                      buffer. Whenever Emacs passes a structure to
                      Python, an extra pointer is generated on the
                      Emacs side to inhibit garbage collection by
                      Emacs. Python garbage collector detects when
                      the received structure is no longer needed on
                      the Python side, at which time the next
                      communication will tell Emacs to remove the
                      extra pointer. It works symmetrically as
                      well, that is, whenever Python passes a
                      structure to Emacs, an extra Python reference
                      is generated to inhibit garbage collection on
                      the Python side. Emacs garbage collector
                      detects when the received structure is no
                      longer needed on the Emacs side, after which
                      Python will be told to remove the extra
                      reference. For efficiency, those
                      allocation-related messages are delayed,
                      merged and batched together within the next
                      communication having another purpose.</p>

                      <p>Variable <strong class="code">pymacs-trace-transit</strong> may be
                      modified for controlling how and when the
                      <strong class="code">*Pymacs*</strong>
                      buffer, or parts thereof, get erased. By
                      default, this buffer gets erased before each
                      transaction. To make good debugging use of
                      it, first set <strong class="code">pymacs-trace-transit</strong> to
                      either <strong class="code">t</strong> or to
                      some <tt class="docutils literal">(KEEP .
                      LIMIT)</tt>.</p>
                    </div>

                    <div class="section" id="debugging-the-pymacs-helper">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id48">6.3&nbsp;&nbsp;&nbsp;Debugging the Pymacs
                      helper</a></h2>

                      <p>The Pymacs helper is a Python program
                      which accepts options and arguments. The
                      available options, which are only meant for
                      debugging, are:</p>

                      <blockquote>
                        <table class="docutils option-list" frame="void" rules="none">
                          <colgroup><col class="option">
                          <col class="description">

                          </colgroup><tbody valign="top">
                            <tr>
                              <td class="option-group">
                              <kbd><span class="option">-d
                              <var>FILE</var></span></kbd></td>

                              <td>Debug the protocol to FILE</td>
                            </tr>

                            <tr>
                              <td class="option-group">
                              <kbd><span class="option">-s
                              <var>FILE</var></span></kbd></td>

                              <td>Trace received signals to
                              FILE</td>
                            </tr>
                          </tbody>
                        </table>
                      </blockquote>

                      <ul class="simple">
                        <li>The <tt class="docutils literal"><span class="pre">-d</span></tt> option saves a copy of
                        the communication protocol in the given
                        file, as seen from the Pymacs helper. The
                        file should be fairly identical to the
                        contents of the <strong class="code">*Pymacs*</strong> buffer within
                        Emacs.</li>

                        <li>The <tt class="docutils literal"><span class="pre">-s</span></tt> option monitors most
                        signals received by the Pymacs helper and
                        logs them in the given file. Each log line
                        merely contains a signal number, possibly
                        followed by a star if the interruption was
                        allowed in. Besides logging, signals are
                        usually ignored.</li>
                      </ul>

                      <p>The arguments list directories to be added
                      at the beginning of the Python module search
                      path, and whenever Emacs launches the Pymacs
                      helper, the contents of the Emacs Lisp
                      <strong class="code">pymacs-load-path</strong> variable is
                      turned into this argument list.</p>

                      <p>The Pymacs helper options may be set
                      through the <strong class="code">PYMACS_OPTIONS</strong> environment
                      variable. For example, one could execute
                      something like:</p>
                      <pre class="literal-block">export PYMACS_OPTIONS='-d /tmp/pymacs-debug -s /tmp/pymacs-signals'
</pre>

                      <p>in a shell (presuming <strong class="code">bash</strong> here) and start Emacs
                      from that shell. Then, when Emacs launches
                      the Pymacs helper, the above options are
                      transmitted to it.</p>
                    </div>

                    <div class="section" id="emacs-usual-debugging">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id49">6.4&nbsp;&nbsp;&nbsp;Emacs usual debugging</a></h2>

                      <p>If cross-calls between Emacs Lisp and
                      Python nest deeply, an error will raise
                      successive exceptions alternatively on both
                      sides as requests unstack, and the diagnostic
                      gets transmitted back and forth, slightly
                      growing as we go. So, errors will eventually
                      be reported by Emacs. I made no kind of
                      effort to transmit the Emacs Lisp back trace
                      on the Python side, as I do not see a purpose
                      for it: all debugging is done within Emacs
                      windows anyway.</p>

                      <p>On recent Emacses, the Python back trace
                      gets displayed in the mini-buffer, and the
                      Emacs Lisp back trace is simultaneously shown
                      in the <strong class="code">*Backtrace*</strong> window. One
                      useful thing is to allow to mini-buffer to
                      grow big, so it has more chance to fully
                      contain the Python back trace, the last lines
                      of which are often especially useful. Here, I
                      use:</p>
                      <pre class="literal-block">(setq resize-mini-windows t
      max-mini-window-height .85)
</pre>

                      <p>in my <tt class="file docutils literal">.emacs</tt> file, so
                      the mini-buffer may use 85% of the screen,
                      and quickly shrinks when fewer lines are
                      needed. The mini-buffer contents disappear at
                      the next keystroke, but you can recover the
                      Python back trace by looking at the end of
                      the <strong class="code">*Messages*</strong>
                      buffer. In which case the <strong class="code">ffap</strong> package in Emacs may be
                      yet another friend! From the <strong class="code">*Messages*</strong> buffer, once
                      <strong class="code">ffap</strong> activated,
                      merely put the cursor on the file name of a
                      Python module from the back trace, and
                      <tt class="docutils literal"><span class="pre">C-x</span> <span class="pre">C-f</span>
                      RET</tt> will quickly open that source for
                      you.</p>
                    </div>

                    <div class="section" id="python-usual-debugging">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id50">6.5&nbsp;&nbsp;&nbsp;Python usual debugging</a></h2>

                      <p>A common way to debug a Python script is
                      to spread it with <strong class="code">print</strong> commands. When such a
                      Python script is executed under Pymacs
                      control, these <strong class="code">print</strong> statements display the
                      results right within the <strong class="code">*Pymacs*</strong> buffer, and may be
                      observed there.</p>

                      <p>As such output gets intermixed with the
                      Pymacs protocol itself, never ever print the
                      symbol <tt class="docutils literal">&lt;</tt>, immediately
                      followed by the expression of a decimal
                      number, immediately followed by a horizontal
                      tab (<tt class="docutils literal">\t</tt>).
                      If you were doing so, the communication
                      protocol would get pretty mixed up, and
                      Pymacs would break. But you do not have to
                      worry much about this: the forbidden sequence
                      is unlikely in practice, would it be only
                      because people do not often use horizontal
                      tabs anymore — oh, tabs were once undoubtedly
                      popular, but this was many years ago…</p>
                    </div>

                    <div class="section" id="auto-reloading-on-save">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id51">6.6&nbsp;&nbsp;&nbsp;Auto-reloading on save</a></h2>

                      <p>I found useful to automatically
                      <strong class="code">pymacs-load</strong>
                      some Python files whenever they get saved
                      from Emacs. This can be decided on a per-file
                      or per-directory basis. To get a particular
                      Python file to be reloaded automatically on
                      save, add the following lines at the end:</p>
                      <pre class="literal-block"># Local Variables:
# pymacs-auto-reload: t
# End:
</pre>

                      <p>Here is an example of automatic reloading
                      on a per-directory basis. The code below
                      assumes that Python files meant for Pymacs
                      are kept in <tt class="file docutils literal">~/share/emacs/python</tt>:</p>
                      <pre class="literal-block">(defun fp-maybe-pymacs-reload ()
  (let ((pymacsdir (expand-file-name "~/share/emacs/python/")))
    (when (and (string-equal (file-name-directory buffer-file-name)
                             pymacsdir)
               (string-match "\\.py\\'" buffer-file-name))
      (pymacs-load (substring buffer-file-name 0 -3)))))
(add-hook 'after-save-hook 'fp-maybe-pymacs-reload)
</pre>
                    </div>
                  </div>

                  <div class="section" id="administrative-miscellany">
                    <h1><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id52">7&nbsp;&nbsp;&nbsp;Administrative miscellany</a></h1>

                    <div class="section" id="development-history">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id53">7.1&nbsp;&nbsp;&nbsp;Development history</a></h2>

                      <p>I once hungered for a Python-extensible
                      editor, so much so that I pondered the idea
                      of dropping Emacs for other avenues, but
                      found nothing much convincing. Moreover,
                      looking at all Lisp extensions I'd made for
                      myself, and considering all those superb
                      tools written by others, all of which are now
                      part of my computer life, it would have been
                      a huge undertaking for me to reprogram these
                      all in Python. So, when I began to see that
                      something like Pymacs was possible, I felt
                      strongly motivated! :-)</p>

                      <p>Pymacs draws on previous work of Cedric
                      Adjih that enabled the running of Python as a
                      process separate from Emacs. See <a class="reference external" href="http://www.crepuscule.com/pyemacs/">http://www.crepuscule.com/pyemacs/</a>,
                      or write Cedric at <a class="reference external" href="mailto:adjih-pam@crepuscule.com">mailto:adjih-pam@crepuscule.com</a>.
                      Cedric presented <strong class="code">pyemacs</strong> to me as a proof of
                      concept. As I simplified that concept a bit,
                      I dropped the <tt class="docutils literal">e</tt> in <tt class="docutils literal">pyemacs</tt> :-). Cedric
                      also previously wrote patches for linking
                      Python right into XEmacs, but abandoned the
                      idea, as he found out that his patches were
                      unmaintainable over the evolution of both
                      Python and XEmacs.</p>

                      <p>As Brian McErlean independently and
                      simultaneously wrote a tool similar to this
                      one, we decided to merge our projects. In an
                      amusing coincidence, he even chose
                      <strong class="code">pymacs</strong> as a
                      name. Brian paid good attention to complex
                      details that escaped my courage, so his help
                      and collaboration have been beneficial. You
                      may reach Brian at <a class="reference external" href="mailto:brianmce@crosswinds.net">mailto:brianmce@crosswinds.net</a>.</p>

                      <p>The initial throw at Pymacs has been
                      written on 2001-09-05, and releases in the
                      0.x series followed in a rapid pace for a few
                      months, and Pymacs soon became stable.
                      Reported bugs or suggestions were minor, and
                      the feature set was fairly usable from the
                      start. For a long while, there was not enough
                      new material to warrant other releases.</p>

                      <p>Later, someone begged me to consider Vim,
                      and not only Emacs, for some tools I was then
                      writing (in the area of musical scores).
                      Looking at Vim more closely, I discovered
                      that it is a worth editor, with Python nicely
                      integrated, enough for me to switch. In a
                      <a class="reference external" href="http://pinard.progiciels-bpi.ca/opinions/editors.html">
                      Web article</a> (which many enjoyed, as they
                      told me), I detailed my feelings on these
                      matters.</p>

                      <p>I switched from Emacs to Vim in my
                      day-to-day habits, and because of this, felt
                      that Pymacs needed a more credible maintainer
                      than me. Syver Enstad, who was an
                      enthusiastic user and competent contributor,
                      was kind enough to accept the duty (2003-10).
                      Syver then became unavailable, to the point I
                      could not contact him in years. I would
                      loathe to see myself interfering with an
                      official maintainer, but after I decided to
                      return to some moderate Emacs usage, and
                      because of the long silence, I considered
                      resuming Pymacs maintenance (2007-11), and
                      did it (2008-01).</p>

                      <p>Giovanni Giorgi once (2007-03) wanted to
                      expand on Pymacs and publish it on his own,
                      and later felt like maintaining it whole
                      (late 2007-12). I rather suggested an attempt
                      at collaborative maintenance, and this
                      experiment is still going on...</p>
                    </div>

                    <div class="section" id="should-it-come-with-emacs">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id54">7.2&nbsp;&nbsp;&nbsp;Should it come with
                      Emacs?</a></h2>

                      <p>Gerd Möllman, who was maintaining Emacs at
                      the time of Pymacs birth and development,
                      retrofitted (2001-09) the idea of a
                      <strong class="code">post-gc-hook</strong>
                      from XEmacs, as a way to facilitate memory
                      management within Pymacs.</p>

                      <p>Richard Stallman once suggested (2001-10)
                      that Pymacs be distributed within Emacs, and
                      while discussing the details of this, I
                      underlined small technical difficulties about
                      Emacs installing the Python parts, and the
                      need of a convention about where to install
                      Python files meant for Pymacs. As Richard
                      felt, at the time, very overwhelmed with
                      other duties, no decision was taken and the
                      integration went nowhere.</p>

                      <p>After Gerd resigned as an Emacs
                      maintainer, someone from the Emacs
                      development team wrote again (2002-01) asking
                      information about how to integrate Pymacs. It
                      was easy for me to write a good and thorough
                      summary, after all these discussions with
                      Richard. And that's the end of the story: I
                      never heard of it again. :-)</p>
                    </div>

                    <div class="section" id="the-future-of-pymacs">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id55">7.3&nbsp;&nbsp;&nbsp;The future of Pymacs</a></h2>

                      <p>Some people suggested important internal
                      Pymacs changes. In my opinion, new bigger
                      features are better implemented in a careful
                      way, first as examples or contributions, and
                      moved closer to internal integration
                      depending on how users use or appreciate
                      them. For now, Pymacs should concentrate at
                      doing its own humble job well, and resist
                      bloat.</p>

                      <p>Before Pymacs closes to some version 1.0,
                      some specifications should be revisited, user
                      suggestions pondered, porting matters
                      documented. The test suite should grow up, we
                      should collect more examples. Pymacs should
                      aim seamless integration with <tt class="file docutils literal">.el</tt> files and
                      with transparent <strong class="code">autoload</strong> (my little tries
                      were not so successful). On the Python side,
                      Pymacs <em>might</em> fake primitives like
                      <strong class="code">getindex</strong> and
                      <strong class="code">putindex</strong>, and
                      better support iterators and some newer
                      Python features.</p>

                      <p>Pymacs is not much geared towards Python
                      threads. It is not clear yet if it would be
                      reasonably tractable to better support
                      them.</p>
                    </div>
                  </div>

                  <div class="section" id="technical-miscellany">
                    <h1><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id56">8&nbsp;&nbsp;&nbsp;Technical miscellany</a></h1>

                    <div class="section" id="known-bugs-or-limitations">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id57">8.1&nbsp;&nbsp;&nbsp;Known bugs or
                      limitations</a></h2>

                      <p>What is the difference between a bug and a
                      limitation? <em>Limitations</em> are either
                      bugs not worth repairing, or else, bugs that
                      we do not know yet how to repair. While
                      documenting a bug is indeed a way to postpone
                      its solution, it does not necessarily turns
                      it into a limitation.</p>

                      <p>On a mailing list I once closely followed,
                      a few maintainers were getting very, very
                      upset whenever the word <em>bug</em> happened
                      to be used in any message, especially if the
                      bug was documented. A distinguished member on
                      this list (William N. Venable) coined the
                      wonderful word <em>unfelicity</em>, as a way
                      to discuss problems while avoiding human
                      damage.</p>

                      <p>Such delicacies are surely unneeded for
                      Pymacs. A bug is a bug!</p>

                      <div class="section" id="needed-control-on-stack-unwinding">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id58">8.1.1&nbsp;&nbsp;&nbsp;Needed control on stack
                        unwinding</a></h3>

                        <p>As Ali Gholami Rudi nicely summarized it
                        (2008-02-12):</p>

                        <blockquote>
                          <cite>Lisp programmers could use</cite>
                          <strong class="code">inhibit-quit</strong> <cite>at
                          various levels of recursion, and use
                          Pymacs at these various levels. As an
                          Emacs</cite> <strong class="code">quit</strong> <cite>might
                          propagate out of the stack, but stopping
                          at various levels of it when the Lisp
                          programmers took measures for it, I think
                          there is no choice that finding some
                          mechanism by which Python will unstack in
                          parallel with Emacs, that is, no more and
                          no less, so if Emacs resumes processing
                          at some intermediate level, Python should
                          be ready at the exact corresponding level
                          on its side.</cite>
                        </blockquote>

                        <p>By doing <tt class="docutils literal"><span class="pre">pymacs-eval</span> <span class="pre">"(time.sleep(10))"</span></tt>, and
                        quitting, I once saw that:</p>

                        <blockquote>
                          <ul class="simple">
                            <li>Emacs does not interrupt at once,
                            and if <strong class="code">inhibit-quit</strong> remains
                            set while Emacs waits for the Pymacs
                            helper, this is surely not user
                            friendly!</li>

                            <li>At the end of the wait, I get a
                            spurious IO error (I do not know where
                            it comes from).</li>
                          </ul>
                        </blockquote>
                      </div>

                      <div class="section" id="possible-memory-leak">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id59">8.1.2&nbsp;&nbsp;&nbsp;Possible memory
                        leak</a></h3>

                        <p>Memory may leak in some theoretical
                        circumstances (I say theoretical, because
                        no one ever reported this as being an
                        actual problem). As Richard Stallman once
                        put it (2002-08):</p>

                        <blockquote>
                          <cite>I wonder, though, can this</cite>
                          [memory management] <cite>technique fully
                          handle cycles that run between Lisp and
                          Python? Suppose Lisp object A refers to
                          Python object B, which refers to Lisp
                          object A, and suppose nothing else refers
                          to either one of them. Will you succeed
                          in recognizing these two objects as
                          garbage?</cite>
                        </blockquote>
                      </div>

                      <div class="section" id="death-from-a-ctrl-c">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id60">8.1.3&nbsp;&nbsp;&nbsp;Death from a
                        Ctrl-C</a></h3>

                        <p>Ali Gholami Rudi notices (2008-02-20)
                        that Pymacs dies over:</p>
                        <pre class="literal-block">M-x pymacs-eval RET lisp.kbd('C-c r r') RET
</pre>

                        <p>as there is a <tt class="docutils literal"><span class="pre">Ctrl-C</span></tt> in the value
                        returned from Emacs.</p>
                      </div>
                    </div>

                    <div class="section" id="suggestions-to-ponder">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id61">8.2&nbsp;&nbsp;&nbsp;Suggestions to ponder</a></h2>

                      <div class="section" id="python-driven-pymacs">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id62">8.2.1&nbsp;&nbsp;&nbsp;Python-driven
                        Pymacs</a></h3>

                        <p>I guess the most important improvement
                        we could think to Pymacs would be some
                        machinery by which Python programs, started
                        outside Emacs, could access Pymacs, once it
                        started. That could be useful at least for
                        testing or debugging, and maybe for more
                        serious work as well. These are mere
                        thoughts, I do not plan working at this
                        soon, unless I have an actual need. But if
                        the challenge interests someone, please go
                        ahead!</p>

                        <p>Here is how it could go. Pymacs has a
                        Python interpreter running as a sub-process
                        of Emacs. In fact, Emacs loads <tt class="file docutils literal">pymacs.el</tt>,
                        which in turn gets Python to execute
                        <tt class="file docutils literal">pymacs.py</tt>, and
                        both communicate afterwards. <tt class="file docutils literal">pymacs.py</tt> is
                        only active whenever <tt class="file docutils literal">pymacs.el</tt>
                        calls it, otherwise it is blocked.
                        <tt class="file docutils literal">pymacs.py</tt>
                        could, under some option, start another
                        thread within itself. The initial thread
                        would block waiting for Emacs, as usual.
                        The second thread would block waiting to
                        serve any Python client wanting to access
                        Emacs. When this occurs, the second thread
                        would queue a request for the first thread,
                        and then send a signal to Emacs so it
                        triggers a Pymacs communication. At each
                        communication opportunity, the first thread
                        on the Python side might fully service the
                        queue from the second thread.</p>
                      </div>

                      <div class="section" id="autoloading-interface">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id63">8.2.2&nbsp;&nbsp;&nbsp;Autoloading
                        interface</a></h3>

                        <p>I once tried better interfacing to
                        <strong class="code">autoload</strong>, and
                        failed. It got more intricate that I
                        thought it would be. I might revisit this,
                        but in low priority.</p>

                        <p>In the meantime, one may use a small
                        <tt class="file docutils literal">.el</tt>
                        file, like this one, on the Emacs load
                        path:</p>
                        <pre class="literal-block"># File zorglub.el — just load zorglub.py.
(pymacs-load "zorglub")
(provide 'zorglub)
</pre>

                        <p>and then use either one of:</p>
                        <pre class="literal-block">(require 'zorglub)             ; in Lisp
lisp.require(lisp.zorglub)     # in Python
</pre>

                        <p>at the beginning of body for any
                        function needing functions from <tt class="file docutils literal">zorglub.py</tt>.
                        One may also write one or many:</p>
                        <pre class="literal-block">(autoload 'FUNCTION-NAME "zorglub" nil t)
</pre>

                        <p>to indirectly autoload <tt class="file docutils literal">zorglub.py</tt> as
                        needed.</p>
                      </div>

                      <div class="section" id="handling-more-special-forms">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id64">8.2.3&nbsp;&nbsp;&nbsp;Handling more special
                        forms</a></h3>

                        <p>The discussion started about the lack of
                        specific Pymacs support, on the Python
                        side, for the Emacs Lisp <strong class="code">setq-default</strong> function.
                        People also mentioned <strong class="code">defvar</strong> and <strong class="code">defcustom</strong>, but there are
                        really many other special forms in Emacs
                        Lisp. (A special form is any expression
                        form in which all arguments are not all
                        blindly evaluated before the function
                        actually enters. The function then receives
                        the arguments unevaluated, and it is its
                        responsibility to choose which arguments
                        should be evaluated, and when.)</p>

                        <p>The fact is that, besides <strong class="code">setq</strong> and some forms of
                        <strong class="code">defun</strong>,
                        functions, few special forms are supported
                        in Pymacs. One may think of <strong class="code">let</strong>, functions like
                        <strong class="code">save-excursion</strong>, etc. But
                        that's all, and maybe debatable as too much
                        already. The real problem to solve is
                        supporting special forms (and macros) at
                        Pymacs level. If we create special cases in
                        Pymacs for each special form we happen to
                        stumble upon, Pymacs might loose its
                        elegance, and so, we have to stay a bit
                        careful.</p>

                        <p>All special forms require that the user
                        somehow defeat the fact that Pymacs
                        evaluate all function arguments before
                        calling a Lisp function. I realise it might
                        be a subtle point for people unfamiliar
                        with Lisp. <strong class="code">apply</strong> on the Lisp side
                        applies a function on a list of arguments,
                        so the trick is to evaluate on the Python
                        side something yielding a list, the
                        contents of which are to be actual
                        arguments. I'm not fully sure this is the
                        good direction to take, even if easy — I
                        mean here, that the real problem to solve
                        is something else.</p>

                        <p>On a related matter, Ali Gholami Rudi
                        suggested that Pymacs supports Emacs
                        so-called <em>keyword arguments</em>, and
                        even provide a simple patch to do so:</p>
                        <pre class="literal-block">diff --git a/Pymacs/pymacs.py b/Pymacs/pymacs.py
--- a/Pymacs/pymacs.py
+++ b/Pymacs/pymacs.py
@@ -453,13 +453,16 @@
             write(') nil)')
             lisp._eval(''.join(fragments))

-    def __call__(self, *arguments):
+    def __call__(self, *arguments, **keywords):
         fragments = []
         write = fragments.append
         write('(%s' % self.text)
         for argument in arguments:
             write(' ')
             print_lisp(argument, write, True)
+        for kwd, value in keywords.items():
+            write(' :%s ' % kwd)
+            print_lisp(value, write, True)
         write(')')
         return lisp._eval(''.join(fragments))
</pre>

                        <p>So far that I understand, there are just
                        no keyword arguments in Emacs. Keywords
                        might be nothing but a mirage created by
                        <strong class="code">defcustom</strong>
                        only (maybe through <strong class="code">define-minor-mode</strong>) and
                        <strong class="code">defstruct</strong> --
                        is there any other usage for keywords? So I
                        wonder if this unusual trickery, not even a
                        real part of Emacs Lisp, is important
                        enough to warrant modifying something as
                        fundamental as <strong class="code">__call__</strong> in Pymacs. Part of
                        my reluctance might also come from my
                        (unsubstanciated) fear that the above
                        change would slow down the hearth of
                        Pymacs.</p>

                        <p>For now at least, users are invited to
                        use <tt class="docutils literal"><span class="pre">lisp(...)</span></tt> for all other
                        special forms. It's simple, it's rather
                        safe. Things like:</p>
                        <pre class="literal-block">lisp('(setq-default %s %s)' % (name, value))
</pre>

                        <p>are not so horrible... :-) Deep down,
                        <tt class="docutils literal">lisp()</tt>
                        calls are what Pymacs do all the time under
                        the table, all the rest are bits of sugar.
                        What would be needed is a visit to this
                        special form support with wider eyes and
                        mind, come up with a general unifying
                        solution, rather than multiplying special
                        cases.</p>
                      </div>

                      <div class="section" id="support-for-python-dictionaries">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id65">8.2.4&nbsp;&nbsp;&nbsp;Support for Python
                        dictionaries</a></h3>

                        <p>While Pymacs mirrors Python tuples and
                        lists into Emacs Lisp vectors and lists, it
                        has nothing currently to reflect Python
                        dictionaries.</p>

                        <p>It has been suggested to use Emacs Lisp
                        alists to do so, but this does not seem
                        adequate to me. Pymacs 0.0 and 0.1 did
                        convert Python dicts to Emacs Lisp alists.
                        This was a mere toy to get experience with
                        the Pymacs mechanics, not a serious idea.
                        Despite I wanted <em>something</em> for
                        Python dicts, this choice was not very
                        satisfying:</p>

                        <blockquote>
                          <ul class="simple">
                            <li>Dicts access speed are O(1); alists
                            are O(N).</li>

                            <li>Dicts have no intrinsic order;
                            alists are really a sequence.</li>

                            <li>Dicts have no duplicate keys;
                            alists may have shadows.</li>
                          </ul>
                        </blockquote>

                        <p>The last two points, in particular, have
                        the consequence that one cannot convert
                        back and forth from Lisp and have results
                        which compare with <tt class="docutils literal">(equal <span class="pre">...)</span></tt>. This makes the
                        equivalence especially ugly. Proper lists
                        and vectors in Lisp can be converted back
                        and forth to Python and be <tt class="docutils literal">(equal <span class="pre">...)</span></tt>, so those
                        equivalences are bearable. The dict
                        conversion was withdrawn in Pymacs 0.2; I
                        thought I should better postpone until a
                        better idea pops up, than let users develop
                        habits with something wrong and doomed to
                        be replaced.</p>

                        <p>Emacs Lisp hash tables (as in Emacs 21)
                        could be an acceptable equivalent for
                        Python dicts. This is what Brian McErlean
                        did, and suggests. My only reservation is
                        about the Python need for non-mutable keys,
                        something which Emacs does not guarantee.
                        As by default, from Lisp to Python,
                        references are transmitted instead of
                        contents, this would be a possible problem
                        only when an expanded copy is requested
                        from the Python side. This would never be a
                        problem going from Python to Emacs, so far
                        as I understand things now.</p>
                      </div>

                      <div class="section" id="a-nicer-pymacs-buffer">
                        <h3><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id66">8.2.5&nbsp;&nbsp;&nbsp;A nicer <strong class="code">*Pymacs*</strong> buffer</a></h3>

                        <p>We might improve how the <strong class="code">*Pymacs*</strong> communication
                        buffer looks. Let's sketch this quickly, in
                        any case, I'm not sure how worth this is.
                        The buffer might be turned into a more
                        fully featured Emacs mode, so it can
                        benefit from highlighting and
                        colourisation, and other goodies. The first
                        thing would be to install font-lock
                        definitions. The second thing would be to
                        use indenting to show the proper nesting of
                        calls between Emacs and Python, in both
                        directions. I would prefer this to be done
                        as a display feature, not as part of the
                        communication protocol. A third thing would
                        be to automatically interpret object
                        numbers on both sides, replacing them with
                        clearer text whenever possible — this
                        information may often be deduced from
                        earlier communications. Finally, that mode
                        could allow for some inspection on Pymacs
                        object and status, and maybe also to
                        control the external Python server
                        described in another suggestion in this
                        series, if it ever gets implemented.</p>
                      </div>
                    </div>

                    <div class="section" id="speed-issues">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id67">8.3&nbsp;&nbsp;&nbsp;Speed issues</a></h2>

                      <p>Shoot out projects compare the relative
                      speed of many popular languages, and the
                      relative merits of Lisp and Python might
                      interest Pymacs users. The first URL points
                      to a version oriented towards Win32 systems,
                      the second is more recent but
                      Debian-oriented:</p>

                      <blockquote>
                        <ul class="simple">
                          <li><a class="reference external" href="http://dada.perl.it/shootout/index.html">
                          http://dada.perl.it/shootout/index.html</a></li>

                          <li><a class="reference external" href="http://shootout.alioth.debian.org/">http://shootout.alioth.debian.org/</a></li>
                        </ul>
                      </blockquote>

                      <p>I've not heard of any Python to Lisp
                      compiler. Lisp may be slow or fast depending
                      on how one uses it, and how much one uses
                      declarations. Some Lisp systems have really
                      excellent compilers, that give very fast code
                      when properly hinted.</p>

                      <p>Python itself may be slow or fast, once
                      again depending on how one uses it. With the
                      proper bend, one can develop the habit of
                      writing Python which shows honest speed. And
                      there is always Pyrex (and the very similar
                      Cython), which is Python complemented with
                      explicit declarations (a bit like some Lisp
                      implementations), and which can buy a lot of
                      speed.</p>

                      <p>This is quite likely that one can have
                      fast programs while using Python, or a mix of
                      Python and either Pyrex or Cython (or even
                      Psyco sometimes), that is, within Python
                      paradigms, without feeling any need of
                      resorting to Lisp.</p>

                      <p>If Python looks like being slow while
                      being used with Emacs, the problem probably
                      lies in Emacs-Python communication which
                      Pymacs implements. One has to learn how to do
                      the proper compromises for having less
                      communications. (In that regard, Vim and
                      Python are really linked together, so Python
                      in Vim is likely faster than Pymacs for
                      someone who does not pay special attention to
                      such matters.)</p>

                      <p>Ali Gholami Rudi also writes
                      (2008-02):</p>

                      <blockquote>
                        <p><cite>Well, there seems to be lots of
                        overhead when transferring large strings.
                        Transferring them requires:</cite></p>

                        <blockquote>
                          <ol class="arabic simple">
                            <li><cite>escaping characters in the
                            strings</cite></li>

                            <li><cite>putting them in</cite>
                            <strong class="code">*Pymacs*</strong>
                            <cite>buffer</cite></li>

                            <li><cite>sending the region to Python
                            process</cite></li>

                            <li><cite>evaluating the Python string
                            in Python-side (involves
                            compiling)</cite></li>
                          </ol>
                        </blockquote>

                        <p><cite>In my experiments, transferring a
                        ~5k-line file takes more than a second on a
                        relatively new computer (data from</cite>
                        <strong class="code">rope-dev</strong><cite>). Improving
                        that probably requires a new protocol that
                        does not use Python eval and has an
                        optional debug buffer. Probably few
                        applications need to transfer large strings
                        to Python but if they do, it is quite
                        slow.</cite></p>
                      </blockquote>

                      <p>All in all, speed may sometimes become a
                      real issue for Pymacs. I once wrote within
                      <a class="reference external" href="http://pinard.progiciels-bpi.ca/opinions/editors.html">
                      http://pinard.progiciels-bpi.ca/opinions/editors.html</a>
                      :</p>

                      <blockquote>
                        <cite>While Pymacs is elegant in my
                        opinion, one cannot effectively use Pymacs
                        (the Python part) without knowing at least
                        the specification of many Lisp functions,
                        and I found that it requires some doing for
                        a Pymacs developer to decouple the Emacs
                        interaction part from the purer algorithmic
                        part in applications. Moreover, if you do
                        not consider speed issues, they bite
                        you.</cite>
                      </blockquote>
                    </div>

                    <div class="section" id="vim-related-thoughts">
                      <h2><a class="toc-backref" href="http://pymacs.progiciels-bpi.ca/pymacs.html#id68">8.4&nbsp;&nbsp;&nbsp;Vim-related thoughts</a></h2>

                      <p>Emacs Lisp is deeply soldered into Emacs
                      internals. Vim has its own language, which
                      people sometimes call Vimscript, similarly
                      tightened into Vim. My feeling is that Emacs
                      Lisp allows for a more intimate handling of
                      edit buffers and external processes than
                      Vimscript does, yet this intimacy has a price
                      in complexity, so all totalled, they may be
                      perceived as comparable for most practical
                      purposes.</p>

                      <p>Pymacs allows customising Emacs with
                      Python instead of Emacs Lisp, and then runs
                      Python as a process external to Emacs, with a
                      communication protocol between both
                      processes. Python may be built into Vim, and
                      then both Python and Vim use a single
                      process. The same as Pymacs gives access to
                      almost all of Emacs Lisp, Python within Vim
                      gives access to almost all of Vimscript, but
                      with a much smaller overhead than Pymacs.</p>

                      <p>Pymacs is not Emacs Lisp, and Python in
                      Vim is not Vimscript either, tweaks are
                      needed in both cases for accessing some of
                      the underlying scripting facilities. Pymacs
                      is rather elegant, Python in Vim is rather
                      clean. Python itself is both elegant and
                      clean, but one strong point of Python for me
                      is the legibility, which builds deeper roots
                      on the clean side than on the elegant side.
                      All in all, despite I know how debatable it
                      can be, I guess I now have a prejudice
                      towards Python in Vim.</p>

                      <p>I figured out a simple way to have the
                      same Python source usable both within Pymacs
                      or Vim. However, Emacs is byte oriented,
                      while Vim is line oriented. In a few Pymacs
                      applications of mine, I internally toggle
                      between line orientation and byte
                      orientation, keeping both for speed most
                      probably, while I see things would be a bit
                      simpler (and maybe slower) if I was pushing
                      myself on the line-oriented side. Each of
                      Emacs and Vim have their own logic and
                      elegance, and it is probable that we loose
                      overall if we try to emulate one with the
                      other.</p>

                      <p>The idea traversed me to convert all the
                      few Pymacs examples so they work both for
                      Pymacs and Vim, and through the
                      documentation, publicise how people writing
                      Python extensions could write them for both
                      editors at once. Yet, while doing so, one has
                      to stretch either towards Emacs or Vim, and I
                      guess I would favour Vim over Emacs when the
                      time comes to evaluate efficiency-related
                      choices.</p>

                      <p>I also thought about writing a Pymacs
                      module for running Python scripts already
                      written for Vim, by offering a compatibility
                      layer. The complexity of this might be
                      unbounded, I should study actual Python
                      scripts for Vim before knowing better if this
                      is thinkable or not.</p>
                    </div>
                  </div>
                </div>
              </td>
            </tr>
          </tbody></table>
        </td>

        <td class="vr"></td>

        <td class="menu" valign="top">
          <ul>
            <li class="caption">General info</li>

            <li class="entry"><a href="http://pymacs.progiciels-bpi.ca/index.html">Entry
            page</a></li>

            <li class="entry"><a href="http://pinard.progiciels-bpi.ca/index.html">Author's
            site</a></li>

            <li class="entry"><a href="http://pinard.progiciels-bpi.ca/notes/Powered_by_t.html">
            Powered by</a></li>

            <li class="caption">Documentation</li>

            <li class="entry"><a href="http://pymacs.progiciels-bpi.ca/README.html">README</a></li>

            <li class="entry"><a href="./Pymacs version 0.24-beta2_files/Pymacs version 0.24-beta2.html">Manual</a></li>

            <li class="caption">Source files</li>

            <li class="entry"><a href="http://github.com/pinard/Pymacs">Browse</a></li>

            <li class="entry"><a href="http://github.com/pinard/Pymacs/downloads">Download</a></li>

            <li class="caption">Development</li>

            <li class="entry"><a href="http://pymacs.progiciels-bpi.ca/TODO.html">TODO</a></li>

            <li class="entry"><a href="http://pymacs.progiciels-bpi.ca/THANKS.html">Contributors</a></li>
          </ul>
        </td>
      </tr>
    </tbody></table>
  </div>


</body></html>